{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cosmos Documentation","text":"<p>Welcome to the official documentation for Cosmos \u2014 a minimal, musl-first, static binary package management system for people who want their OS to survive without Bash, Python, or curl.</p> <p>This documentation covers core concepts, architecture, CLI usage, Nova scripting, system bootstrapping, and how to maintain your own galaxies\u2014without summoning <code>libgit2</code>.</p>"},{"location":"#getting-started","title":"\ud83e\udded Getting Started","text":"<ul> <li>00 \u2013 Overview</li> <li>01 \u2013 Architecture</li> <li>02 \u2013 Core Concepts</li> <li>03 \u2013 File Formats</li> <li>04 \u2013 Nebula vs Constellation</li> <li>05 \u2013 Glossary</li> </ul>"},{"location":"#using-cosmos","title":"\ud83d\udd27 Using Cosmos","text":"<ul> <li>06 \u2013 Caching and Syncing</li> <li>07 \u2013 Flows</li> <li>08 \u2013 CLI</li> <li>09 \u2013 Tooling (Stellar)</li> <li>10 \u2013 Nova (Scripting)</li> <li>11 \u2013 Transport Layer</li> <li>12 \u2013 FFI Integration</li> </ul>"},{"location":"#philosophy-safety","title":"\ud83d\udcad Philosophy &amp; Safety","text":"<ul> <li>13 \u2013 Phase 3 Features</li> <li>14 \u2013 Design Rationale</li> <li>15 \u2013 Security Model</li> <li>16 \u2013 Examples and Usage</li> <li>17 \u2013 FAQ</li> </ul>"},{"location":"#package-galaxy-maintenance","title":"\ud83c\udf0c Package &amp; Galaxy Maintenance","text":"<ul> <li>18 \u2013 Galaxies</li> <li>19 \u2013 Versioning and Releases</li> <li>20 \u2013 Cosmos Contribution Guide</li> <li>21 \u2013 Maintainer Guide for Galaxies &amp; Stars</li> <li>22 \u2013 Crate Policy</li> </ul>"},{"location":"#system-building","title":"\ud83e\uddf1 System Building","text":"<ul> <li>23 \u2013 Bootstrapping</li> </ul>"},{"location":"#want-to-help","title":"\ud83d\udcbe Want to Help?","text":"<p>Pull requests are welcome. Stars are cool. Nebulae are cooler. We don\u2019t need your signature, but we do need your version to bump cleanly.</p> <ul> <li>GitHub: github.com/cosmospkg/cosmos</li> <li>License: MIT</li> </ul> <p>Cosmos is not a lifestyle. It's a recovery plan.</p>"},{"location":"00-Overview/","title":"00 \u2013 Overview","text":"<p>Cosmos is a minimal, statically-linked, vendor-agnostic package management system designed for resilience, portability, and clarity.</p> <p>Originally born from Comet, Cosmos takes the core ideas of ultra-simple packaging and expands them into a clean, modular architecture that can scale from embedded systems to full operating systems.</p>"},{"location":"00-Overview/#goals","title":"\ud83d\ude80 Goals","text":"<ul> <li>Fully static binaries \u2014 no dynamic linking, no runtime dependencies beyond libc</li> <li>Bootstrappable from nothing \u2014 only needs libc and a filesystem to operate</li> <li>Human-readable package definitions \u2014 <code>star.toml</code>, <code>constellation.toml</code>, etc.</li> <li>Multiple install sources \u2014 install packages from:</li> <li>HTTP (enabled by default)</li> <li>HTTPS (optional feature)</li> <li>Cached tarballs</li> <li>Local mirrors</li> <li>Mounted drives or USB sticks</li> <li>No interpreters \u2014 Cosmos does not depend on Bash, Python, Perl, etc.</li> <li>No TLS or crypto stacks required by default \u2014 optional transport features available via <code>cosmos-transport</code></li> <li>Deterministic install flows \u2014 installs and uninstalls are traceable and safe</li> <li>Nebula and Constellation support \u2014 virtual meta-packages and install presets</li> <li>Self-contained system state \u2014 all installed packages tracked in <code>universe.toml</code></li> <li>Cross-arch and cross-host capable \u2014 runs equally well on tiny embedded systems and full desktops</li> </ul>"},{"location":"00-Overview/#core-concepts","title":"\ud83e\uddf0 Core Concepts","text":"<ul> <li>Star: a single package (with metadata, source, dependencies, and install logic)</li> <li>Nebula: a virtual dependency-only Star with no installable files</li> <li>Constellation: a list of Stars used as an install preset</li> <li>Galaxy: a folder containing one or more Star packages and a <code>meta.toml</code></li> <li>Universe: local system state (installed Stars, versions, and file paths)</li> </ul>"},{"location":"00-Overview/#design-principles","title":"\ud83d\udd0d Design Principles","text":"<ul> <li>No shell required: Nova scripting allows safe, portable install logic</li> <li>No TLS required by default: HTTP and file-based installs work out of the box; HTTPS is available as an optional feature</li> <li>No interpreter required: Rust binary only; works even if <code>/usr</code> is broken</li> <li>No central server required: everything can run from local or offline storage</li> </ul> <p>Cosmos is not just a package manager\u2014it is a foundation for building, deploying, and repairing entire operating systems in minimalist or constrained environments.</p>"},{"location":"01-Architecture/","title":"01 \u2013 Cosmos Architecture","text":"<p>Cosmos is built as a modular, layered system with a clear separation of responsibilities. It is designed to function in environments ranging from minimal embedded systems to full desktop Linux setups, while maintaining reliability and transparency.</p>"},{"location":"01-Architecture/#layered-overview","title":"\ud83e\uddf1 Layered Overview","text":"<pre><code>+-----------------------------+\n|      cosmos-cli             | \u2190 User interface (CLI)\n+-----------------------------+\n|      cosmos-core            | \u2190 Core logic: install, uninstall, deps\n+-----------------------------+\n|      cosmos-transport       | \u2190 Remote fetch handling (HTTP required, HTTPS optional)\n+-----------------------------+\n|      cosmos-universe        | \u2190 Installed system state\n+-----------------------------+\n|      stellar (tooling)      | \u2190 Maintainer tools for building packages\n+-----------------------------+\n|      nova (optional)        | \u2190 Lua-based scripting engine for portability\n+-----------------------------+\n|  Filesystem / libc / tar.gz |\n+-----------------------------+\n</code></pre>"},{"location":"01-Architecture/#crates-components","title":"\ud83d\udd27 Crates / Components","text":""},{"location":"01-Architecture/#1-cosmos-core","title":"1. <code>cosmos-core</code>","text":"<p>Core logic for everything: installs, dependency resolution, interacting with constellation indexes and the universe.</p> <ul> <li>Accepts <code>Star</code> and <code>Galaxy</code> objects</li> <li>Handles:</li> <li>Dependency resolution (with semver support)</li> <li>Downloading and extracting tarballs<ul> <li>Delegates all remote fetching to <code>cosmos-transport</code></li> <li>Handles <code>file://</code> paths directly</li> </ul> </li> <li>Exposes <code>install_star</code>, <code>uninstall_star</code>, <code>update_star</code> functions</li> </ul>"},{"location":"01-Architecture/#2-cosmos-transport","title":"2. <code>cosmos-transport</code>","text":"<p>A required subcrate responsible for all non-<code>file://</code> fetches.</p> <ul> <li>Used by <code>cosmos-core</code> to fetch Stars, Galaxies, and tarballs</li> <li>Dispatches by protocol:</li> <li><code>http://</code> \u2192 supported by default (via <code>ureq</code>)</li> <li><code>https://</code> \u2192 opt-in via <code>https</code> feature or <code>transport-https</code> feature in <code>comos-core</code></li> <li><code>ipfs://</code>, <code>ftp://</code>, etc. \u2192 available via additional features</li> <li><code>file://</code> \u2192 not handled here (native to <code>cosmos-core</code>)</li> <li>Built by default with <code>http</code>. Custom builds can slim it down:</li> </ul> <pre><code>default-features = false\nfeatures = [\"http\"]\n</code></pre>"},{"location":"01-Architecture/#3-cosmos-cli","title":"3. <code>cosmos-cli</code>","text":"<p>Terminal interface for users, using <code>clap</code>.</p> <p>Implements commands like:</p> <ul> <li><code>cosmos install foo</code></li> <li><code>cosmos uninstall foo</code></li> <li><code>cosmos update foo</code></li> <li><code>cosmos status</code></li> <li><code>cosmos sync</code></li> </ul> <p>The CLI calls into <code>cosmos-core</code> and reads config from a central TOML file.</p>"},{"location":"01-Architecture/#4-cosmos-universe","title":"4. <code>cosmos-universe</code>","text":"<p>A standalone crate for tracking system state.</p> <ul> <li>Defines <code>universe.toml</code></li> <li>Tracks:<ul> <li>All installed stars</li> <li>Version and file path information</li> </ul> </li> <li>Called by <code>cosmos-core</code> to read/write state</li> <li>No side effects: it is pure data access</li> </ul>"},{"location":"01-Architecture/#5-stellar","title":"5. <code>stellar</code>","text":"<p>Maintainer-side tool for creating and building packages.</p> <p>Functions:</p> <ul> <li>Create new <code>star.toml</code> scaffolds</li> <li>Build package tarballs</li> <li>Run pre- and post-build tests</li> <li>Lint and validate packages</li> </ul> <p>Future versions may integrate with <code>nova</code>.</p>"},{"location":"01-Architecture/#6-nova-optional","title":"6. <code>nova</code> (optional)","text":"<p>Portable scripting engine using Lua.</p> <p>Designed to replace raw shell scripts with something safer and more portable.</p> <ul> <li>Runs inside install contexts</li> <li>Exposes helper functions like <code>run(\"make\")</code>, <code>copy()</code>, etc.</li> <li>Optional and pluggable: not required for stars to function</li> </ul>"},{"location":"01-Architecture/#filesystem-expectations","title":"\ud83d\udcc2 Filesystem Expectations","text":"<ul> <li>Cosmos can install packages from:<ul> <li>HTTP endpoints (enabled by default)</li> <li>HTTPS (optional via feature)</li> <li>Local file paths (cache/mounted disk/USB)</li> </ul> </li> <li>Cosmos uses a cache directory for all downloaded packages</li> <li>Install directory is fully configurable</li> <li>No FHS enforcement unless desired (can run inside <code>/cosmos</code>, <code>/mnt/sysroot</code>, etc.)</li> </ul>"},{"location":"01-Architecture/#stateless-cli-stateful-system","title":"\ud83e\udd6a Stateless CLI, Stateful System","text":"<ul> <li>The CLI is stateless<ul> <li>It only operates via config files and universe data</li> </ul> </li> <li>The system state is managed by <code>cosmos-universe</code><ul> <li>Easily inspectable and replaceable</li> <li>No central database or binary blob</li> </ul> </li> </ul>"},{"location":"01-Architecture/#example-flow","title":"\ud83d\udd27 Example Flow","text":""},{"location":"01-Architecture/#cosmos-install-zlib","title":"<code>cosmos install zlib</code>","text":"<ol> <li>CLI parses command</li> <li>CLI loads config + constellations</li> <li><code>cosmos-core::install_star()</code> is called</li> <li>Dependencies are resolved recursively</li> <li>Star is downloaded (or used from cache)</li> <li>Star is extracted and script is run</li> <li><code>cosmos-universe</code> is updated with star info</li> </ol>"},{"location":"02-Core-Concepts/","title":"02 \u2013 Core Concepts","text":"<p>Cosmos is built around four core abstractions: Stars, Constellations, Galaxies, and the Universe. These concepts form the foundation of how packages are created, grouped, distributed, and tracked within a Cosmos-based system.</p> <p>These abstractions are designed to work whether you\u2019re building from scratch on an embedded board or repairing a half-broken server in a live shell.</p>"},{"location":"02-Core-Concepts/#star","title":"\u2728 Star","text":"<p>A Star is a single package. It can contain software, configuration, or simply reference other Stars. Stars are defined by a <code>star.toml</code> file and optionally include a tarball and install logic.</p> <p>The <code>source</code> field supports both HTTP URLs and local file paths (e.g., <code>/mnt/usb/zlib.tar.gz</code>). HTTPS and other protocols may be supported if Cosmos was built with the appropriate transport features.</p> <p>Tarballs are extracted to a temporary directory before the install script runs.</p>"},{"location":"02-Core-Concepts/#key-fields","title":"Key Fields:","text":"<pre><code>name = \"zlib\"\nversion = \"1.2.13\"\ndescription = \"Compression library\"\ntype = \"normal\"  # or \"nebula\"\nsource = \"http://mirror.example.org/zlib-1.2.13.tar.gz\"\ninstall_script = \"install.lua\"\n\n[dependencies]\nmusl = \"&gt;=1.2.0\"\n</code></pre>"},{"location":"02-Core-Concepts/#star-types","title":"Star Types:","text":"<ul> <li><code>normal</code>: A real package with files to extract and install</li> <li><code>nebula</code>: A virtual package that only contains dependencies (no source, no script)</li> </ul> <p>If using Stellar, the <code>type</code> field is populated by the <code>stellar new-star</code> command.</p> <p>Nebulae can define system roles, such as:</p> <pre><code>name = \"dev-base\"\ntype = \"nebula\"\n\n[dependencies]\nbusybox = \"^1.36\"\nzlib = \"&gt;=1.2\"\ngcc = \"^13\"\n</code></pre>"},{"location":"02-Core-Concepts/#galaxy","title":"\ud83c\udf0c Galaxy","text":"<p>A Galaxy is a collection of Stars\u2014functionally a package repository. It may be hosted remotely over HTTP (enabled by default), on a USB stick, in a local directory, or via Git. HTTPS and other protocols are supported if Cosmos was built with those transport features.</p>"},{"location":"02-Core-Concepts/#structure","title":"Structure:","text":"<pre><code>core-galaxy/\n\u251c\u2500\u2500 meta.toml\n\u251c\u2500\u2500 packages/\n\u2502   \u251c\u2500\u2500 zlib-1.2.13.tar.gz\n\u2502   \u2514\u2500\u2500 busybox-1.36.0.tar.gz\n\u2514\u2500\u2500 stars/\n    \u251c\u2500\u2500 zlib.toml\n    \u2514\u2500\u2500 busybox.toml\n</code></pre>"},{"location":"02-Core-Concepts/#metatoml-example","title":"meta.toml (example):","text":"<pre><code>name = \"core\"\ndescription = \"Core system packages\"\nversion = \"2024.04\"\n</code></pre> <p>Galaxies are synced with the system via <code>cosmos sync</code>, and used during installs or updates.</p>"},{"location":"02-Core-Concepts/#constellation","title":"\ud83c\udf0d Constellation","text":"<p>A Constellation is a simple TOML file that defines a group of Stars. It is not a package and is not tracked in the system state. Constellations act as presets or curated bundles for easy install.</p>"},{"location":"02-Core-Concepts/#example","title":"Example:","text":"<pre><code>name = \"desktop\"\ndescription = \"Minimal desktop experience\"\nmembers = [\n  \"xorg\",\n  \"wayland\",\n  \"alacritty\",\n  \"firefox\"\n]\n</code></pre> <p>Constellations can be installed with:</p> <pre><code>cosmos install --constellation desktop\n</code></pre>"},{"location":"02-Core-Concepts/#universe","title":"\ud83d\udc69\u200d\ud83d\udcbb Universe","text":"<p>The Universe is the local system's package state. It is defined by <code>universe.toml</code> and tracks:</p> <ul> <li>Installed Stars</li> <li>Their versions</li> <li>Files installed by each Star</li> </ul>"},{"location":"02-Core-Concepts/#universetoml-example","title":"universe.toml Example:","text":"<pre><code>[system]\narch = \"x86_64\"\nversion = \"1.0\"\n\n[installed.zlib]\nversion = \"1.2.13\"\nfiles = [\n  \"/usr/lib/libz.so\",\n  \"/usr/include/zlib.h\"\n]\n\n[installed.busybox]\nversion = \"1.36.0\"\nfiles = [\n  \"/bin/busybox\"\n]\n</code></pre> <p>The Universe is updated automatically by Cosmos when Stars are installed or removed. It can be inspected, versioned, or backed up for reproducibility.</p> <p>Cosmos uses file-level tracking to enable uninstall by deletion. It also answers the classic question: \u201cWhat installed this file and why is it breaking my system?\u201d</p>"},{"location":"02-Core-Concepts/#relationships-summary","title":"\u2728 Relationships Summary","text":"Concept Description Tracked in <code>universe.toml</code>? Star A single package definition + install logic Yes Nebula A dependency-only Star (no install logic) Yes Galaxy A remote or local repo of Stars No Constellation A list of Stars to install together No Universe Tracks what is installed + file lists Yes (by definition) <p>Each of these concepts supports the Cosmos goal of minimal, reproducible, resilient system builds\u2014from a live ISO to a hand-assembled rootfs.</p>"},{"location":"03-File-Formats/","title":"03 \u2013 File Formats","text":"<p>This document defines the key file formats used throughout the Cosmos ecosystem. All formats are plaintext and designed to be human-readable, primarily using TOML. These formats cover packages, system state, groups, and repository metadata.</p>"},{"location":"03-File-Formats/#startoml","title":"\ud83d\udcc4 star.toml","text":"<p>Defines a single Star package.</p> <pre><code>name = \"zlib\"\nversion = \"1.2.13\"\ndescription = \"Compression library\"\ntype = \"normal\"  # or \"nebula\" / \"meta\" for meta packages\nsource = \"http://mirror.example.org/zlib-1.2.13.tar.gz\"\ninstall_script = \"install.lua\"\nlicense = \"MIT\"\n\n[authors]\nafroraydude = \"afro@wombat.linux\"\n\n[dependencies]\nmusl = \"&gt;=1.2.0\"\n</code></pre>"},{"location":"03-File-Formats/#required-fields","title":"Required Fields:","text":"<ul> <li><code>name</code>: unique name of the star</li> <li><code>version</code>: SemVer-compatible version string</li> <li><code>type</code>: <code>normal</code> (default) or <code>nebula</code></li> </ul>"},{"location":"03-File-Formats/#optional-fields","title":"Optional Fields:","text":"<ul> <li><code>description</code>: human-readable description</li> <li><code>source</code>: URL or path to a tarball</li> <li><code>install_script</code>: shell script or nova-compatible command string</li> <li><code>license</code>: SPDX-style license string or plain name (e.g. \"MIT\")</li> <li><code>[authors]</code>: map of contributor names to emails</li> <li><code>[dependencies]</code>: map of star names to version requirements</li> </ul>"},{"location":"03-File-Formats/#universetoml","title":"\ud83d\udd0d universe.toml","text":"<p>Tracks the system's currently installed stars and their associated files.</p> <pre><code>[system]\narch = \"x86_64\"\nversion = \"1.0\"\n\n[installed.zlib]\nversion = \"1.2.13\"\nfiles = [\n    \"/usr/lib/libz.so\",\n    \"/usr/include/zlib.h\"\n]\n\n[installed.busybox]\nversion = \"1.36.0\"\nfiles = [\n    \"/bin/busybox\"\n]\n</code></pre>"},{"location":"03-File-Formats/#sections","title":"Sections:","text":"<ul> <li><code>[system]</code>: system metadata</li> <li><code>[installed.&lt;name&gt;]</code>: installed star metadata</li> </ul>"},{"location":"03-File-Formats/#constellationtoml","title":"\ud83c\udf0c constellation.toml","text":"<p>Defines a Constellation: a named list of stars, used as an install preset.</p> <pre><code>name = \"desktop\"\ndescription = \"Base desktop setup\"\nmembers = [\n    \"xorg\",\n    \"firefox\",\n    \"wayland\",\n    \"alacritty\"\n]\n</code></pre>"},{"location":"03-File-Formats/#fields","title":"Fields:","text":"<ul> <li><code>name</code>: name of the constellation</li> <li><code>description</code>: optional text</li> <li><code>members</code>: list of star names</li> </ul> <p>Constellations are not packages and are not tracked in the Universe.</p>"},{"location":"03-File-Formats/#galaxymetatoml","title":"\ud83c\udf0d galaxy/meta.toml","text":"<p>Metadata about a Galaxy (i.e. a repository of stars).</p> <pre><code>name = \"core\"\ndescription = \"Core system packages\"\nversion = \"2025.04.01\"\n\n[stars]\nzlib = \"1.2.13\"\nbusybox = \"1.36.0\"\n</code></pre>"},{"location":"03-File-Formats/#fields_1","title":"Fields:","text":"<ul> <li><code>name</code>: the name of the galaxy</li> <li><code>description</code>: brief overview</li> <li><code>version</code>: a human-readable version tag for the repository snapshot</li> <li><code>stars</code>: list of star names in the galaxy (required for HTTP/S3 hosting)</li> </ul>"},{"location":"03-File-Formats/#galaxy-layout-filesystem","title":"\ud83d\udd17 galaxy layout (filesystem)","text":"<p>Galaxies are just static folders, easily hosted over HTTP, Git, or even a mounted drive.</p> <pre><code>core-galaxy/\n\u251c\u2500\u2500 meta.toml\n\u251c\u2500\u2500 packages/\n\u2502   \u251c\u2500\u2500 zlib-1.2.13.tar.gz\n\u2502   \u2514\u2500\u2500 busybox-1.36.0.tar.gz\n\u251c\u2500\u2500 stars/\n\u2502   \u251c\u2500\u2500 zlib.toml\n\u2502   \u2514\u2500\u2500 busybox.toml\n</code></pre> <ul> <li><code>meta.toml</code> \u2192 info about the galaxy, including star list</li> <li><code>stars/</code> \u2192 individual star definitions (1 per package)</li> <li><code>packages/</code> \u2192 optional tarballs referenced by <code>source</code> fields in star files</li> </ul> <p>This layout is portable, versionable, and supports offline or air-gapped installs.</p>"},{"location":"03-File-Formats/#configtoml","title":"\ud83d\udcc1 config.toml","text":"<p>The main Cosmos config file defines the install root, cache path, and known Galaxy sources.</p> <pre><code>[galaxies]\ncore = \"http://mirror.example.org/core\"\nextra = \"file:///mnt/usb/galaxies/extra\"\ndev = \"./galaxies/devtools\"\n\ninstall_dir = \"/\"\ncache_dir = \"/var/lib/cosmos\"\n</code></pre>"},{"location":"03-File-Formats/#fields_2","title":"Fields:","text":"<ul> <li><code>[galaxies]</code>: map of galaxy name to URL or path</li> <li><code>install_dir</code>: where packages are installed</li> <li><code>cache_dir</code>: where synced files are stored</li> </ul> <p>All Cosmos formats prioritize:</p> <ul> <li>Human readability</li> <li>Git friendliness</li> <li>Simplicity and forward compatibility</li> <li>Minimal external tooling</li> </ul> <p>They are designed so that an entire package ecosystem can be stored, edited, and mirrored using only a text editor and tar.</p>"},{"location":"04-Nebula-vs-Constellation/","title":"04 \u2013 Nebula vs Constellation","text":"<p>Cosmos has two ways to group multiple packages: Nebulae and Constellations. While they may look similar, they serve very different purposes.</p>"},{"location":"04-Nebula-vs-Constellation/#what-is-a-nebula","title":"\ud83c\udf2b\ufe0f What Is a Nebula?","text":"<p>A Nebula is a real Star package. It doesn\u2019t install anything directly\u2014it just defines a list of dependencies. Think of it as a metapackage that\u2019s actually part of your system.</p> <pre><code>name = \"system-core\"\ntype = \"nebula\"\nversion = \"1.0.0\"\n\n[dependencies]\nmusl = \"&gt;=1.2.4\"\nbusybox = \"^1.36\"\nzlib = \"^1.2\"\n</code></pre>"},{"location":"04-Nebula-vs-Constellation/#why-use-a-nebula","title":"\u2705 Why use a Nebula?","text":"<ul> <li>You want it to show up in <code>universe.toml</code></li> <li>You want to version it over time</li> <li>You want other Stars to depend on it (e.g. <code>desktop-core</code> depends on <code>system-core</code>)</li> <li>You care that it exists after installation</li> </ul>"},{"location":"04-Nebula-vs-Constellation/#what-is-a-constellation","title":"\ud83c\udf0c What Is a Constellation?","text":"<p>A Constellation is a TOML file used to install a bunch of Stars in one shot. It is not tracked in your system. It doesn\u2019t show up in <code>universe.toml</code>. It doesn\u2019t do anything after the install finishes.</p> <pre><code>name = \"desktop-tools\"\ndescription = \"Common desktop applications\"\n\nmembers = [\n  \"firefox\",\n  \"kde\",\n  \"alacritty@0.12.0\"\n]\n</code></pre>"},{"location":"04-Nebula-vs-Constellation/#why-use-a-constellation","title":"\u2705 Why use a Constellation?","text":"<ul> <li>You want a one-time install preset</li> <li>You don\u2019t care about uninstalling the group</li> <li>You don\u2019t need it versioned or depended on</li> <li>You want to script a setup or ship a role profile (e.g. <code>developer.toml</code>)</li> </ul>"},{"location":"04-Nebula-vs-Constellation/#concrete-examples","title":"\ud83e\udde0 Concrete Examples","text":"Use Case Nebula (<code>type = \"nebula\"</code>) Constellation Core system foundation \u2705 <code>system-core</code> \u274c Developer tools preset \u274c \u2705 <code>dev-tools.toml</code> Desktop environment bundle \u274c (usually) \u2705 <code>desktop-tools.toml</code> Shared dependency grouping \u2705 \u274c System roles / metapackages \u2705 \u274c Installer presets / profiles \u274c \u2705"},{"location":"04-Nebula-vs-Constellation/#version-pinning-in-constellations","title":"\ud83d\udccc Version Pinning in Constellations","text":"<p>Constellations let you lock exact versions at install time:</p> <pre><code>members = [\n  \"firefox@124.0\",\n  \"nano@^6.0\"\n]\n</code></pre> <p>That makes them ideal for reproducible install flows\u2014even though they\u2019re not tracked.</p>"},{"location":"04-Nebula-vs-Constellation/#tldr","title":"\ud83e\udde0 TL;DR","text":"<ul> <li>Nebula = installable metapackage; tracked, versioned, and usable as a dependency</li> <li>Constellation = one-time install preset; not tracked, not versioned, not depended on</li> </ul> <p>Use Nebulae for structure. Use Constellations for convenience.</p> <p>Still not sure? Ask yourself:</p> <p>\u201cDo I want this to show up in <code>universe.toml</code> or be part of a dependency tree?\u201d</p> <p>If yes \u2192 it\u2019s a Nebula. If no \u2192 it\u2019s a Constellation.</p>"},{"location":"05-Glossary/","title":"05 \u2013 Glossary","text":"<p>This document defines core terms used throughout Cosmos. It provides short, consistent definitions for quick reference or onboarding.</p>"},{"location":"05-Glossary/#star","title":"\u2728 Star","text":"<p>A single package. Contains metadata (<code>star.toml</code>), an optional source tarball, and optional install script or Nova logic.</p>"},{"location":"05-Glossary/#nebula","title":"\u2601\ufe0f Nebula","text":"<p>A special Star with <code>type = \"nebula\"</code>. It has no source or install script, only dependencies. Used to group other Stars under one installable unit.</p>"},{"location":"05-Glossary/#galaxy","title":"\ud83c\udf0c Galaxy","text":"<p>A package repository. A folder containing Star definitions, source tarballs, and a <code>meta.toml</code> with metadata and a list of available Stars. Can be hosted over HTTP, Git, USB, or locally.</p>"},{"location":"05-Glossary/#constellation","title":"\ud83c\udf0d Constellation","text":"<p>A named group of Stars for preset installs. Defined in <code>constellation.toml</code>. Not tracked in the Universe, used only at install time.</p>"},{"location":"05-Glossary/#universe","title":"\ud83d\ude80 Universe","text":"<p>The installed package state of the system. Tracked in <code>universe.toml</code>. Records Star name, version, and installed file paths.</p>"},{"location":"05-Glossary/#stellar","title":"\u2728 Stellar","text":"<p>The builder tool used by maintainers to scaffold, validate, and package Stars. Not required for system usage.</p>"},{"location":"05-Glossary/#nova","title":"\ud83d\udd2e Nova","text":"<p>A Lua-based scripting engine embedded into Cosmos for safe, portable install/build scripts. Replaces shell scripts. Sandbox-enforced.</p> <p>Nova scripts are executed from a temporary directory and receive the <code>install_root</code> variable injected automatically. They can use limited built-in helpers such as <code>run</code>, <code>copy</code>, <code>mkdir</code>, and <code>symlink</code> for common operations.</p>"},{"location":"05-Glossary/#galaxy-cache","title":"\ud83c\udf10 Galaxy Cache","text":"<p>Local directory of synced Galaxies used for install/update/search. Read by Cosmos CLI.</p>"},{"location":"05-Glossary/#config","title":"\ud83d\udcc1 Config","text":"<p>Main configuration file: <code>/etc/cosmos/config.toml</code>. Defines cache directory, install root, and Galaxy sources.</p>"},{"location":"05-Glossary/#real-root","title":"\ud83e\udee0 Real Root","text":"<p>The actual installation target directory. Passed into Nova and used as the base for all file operations.</p>"},{"location":"05-Glossary/#tarball","title":"\u2604\ufe0f Tarball","text":"<p>A <code>.tar.gz</code> archive containing the package's installable files. Built by Stellar. Referenced by <code>source</code> field in <code>star.toml</code>.</p> <p>This glossary ensures all Cosmos tools, docs, and discussions refer to the same concepts consistently and clearly.</p>"},{"location":"06-Caching-and-Syncing/","title":"06 \u2013 Caching and Syncing","text":"<p>This document outlines how Cosmos handles syncing Galaxies and caching packages. It defines the levels of sync available, when things are fetched, and how to control offline behavior.</p> <p>Cosmos does not run a daemon or maintain background state. Everything is initiated and controlled explicitly by CLI commands.</p>"},{"location":"06-Caching-and-Syncing/#sync-levels","title":"\u2728 Sync Levels","text":"<p>Cosmos provides tiered sync strategies based on user intent:</p>"},{"location":"06-Caching-and-Syncing/#cosmos-sync","title":"<code>cosmos sync</code>","text":"<ul> <li>Default sync behavior</li> <li>Downloads only <code>meta.toml</code> files from configured Galaxies</li> <li>Fastest, lowest bandwidth</li> </ul>"},{"location":"06-Caching-and-Syncing/#cosmos-sync-stars","title":"<code>cosmos sync --stars</code>","text":"<ul> <li>Also downloads all <code>star.toml</code> files listed in each Galaxy's <code>meta.toml</code></li> <li>Does not fetch tarballs</li> <li>Allows faster <code>install</code> calls later</li> </ul>"},{"location":"06-Caching-and-Syncing/#cosmos-sync-full","title":"<code>cosmos sync --full</code>","text":"<ul> <li>Fetches <code>meta.toml</code>, all <code>star.toml</code>s, and all <code>.tar.gz</code> packages if:<ul> <li>The <code>source</code> is cacheable (e.g., HTTP, relative file path)</li> </ul> </li> <li>Use this to fully prime a system for offline use</li> </ul>"},{"location":"06-Caching-and-Syncing/#install-behavior","title":"\ud83c\udf0a Install Behavior","text":""},{"location":"06-Caching-and-Syncing/#cosmos-install-foo","title":"<code>cosmos install foo</code>","text":"<ul> <li>Looks for <code>foo.toml</code> in cached Galaxy dirs</li> <li>If not found, tries to download it on-demand (unless <code>--offline</code>)</li> <li>Checks for tarball in cache</li> <li>If missing and source is cacheable (HTTP), downloads it on-demand</li> </ul>"},{"location":"06-Caching-and-Syncing/#cosmos-install-foo-offline","title":"<code>cosmos install foo --offline</code>","text":"<ul> <li>Will fail if either the <code>star.toml</code> or the package tarball is missing from cache</li> <li>Ensures a completely offline installation attempt</li> </ul>"},{"location":"06-Caching-and-Syncing/#local-vs-remote-galaxies","title":"\ud83d\ude84 Local vs Remote Galaxies","text":""},{"location":"06-Caching-and-Syncing/#local-or-mounted-galaxies","title":"Local or Mounted Galaxies","text":"<ul> <li>Sources like <code>file:///mnt/usb/galaxies/core</code> or <code>./galaxies/devtools</code></li> <li>Treated as \"live\" directories</li> <li>No caching is performed</li> <li><code>star.toml</code> and packages are read directly from disk</li> <li>Ideal for development, USB installs, or bundled Galaxies</li> </ul>"},{"location":"06-Caching-and-Syncing/#remote-galaxies-https3","title":"Remote Galaxies (HTTP/S3)","text":"<ul> <li>Sources like <code>http://mirror.example.org/core</code></li> <li>Always synced into the local cache</li> <li><code>cosmos sync</code> determines what gets downloaded</li> <li><code>cosmos install</code> pulls missing files if allowed</li> </ul> <p>Cosmos will never try to cache a local Galaxy. If it\u2019s already on disk, it\u2019s trusted and read as-is.</p>"},{"location":"06-Caching-and-Syncing/#what-cosmos-will-not-do","title":"\ud83d\udeab What Cosmos Will Not Do","text":"<ul> <li>No auto-sync on startup</li> <li>No background updates</li> <li>No index daemon</li> <li>No guessing what you need</li> </ul> <p>Cosmos only syncs what you ask it to. No more, no less.</p>"},{"location":"06-Caching-and-Syncing/#future-enhancements-optional","title":"\ud83c\udfd1 Future Enhancements (Optional)","text":"<ul> <li><code>--diff</code>: show what changed since last sync</li> <li><code>--dry-run</code>: preview what would be downloaded</li> <li><code>--prune</code>: delete unused packages from cache</li> <li>Configurable per-Galaxy sync level (e.g. <code>core = \"full\"</code>, <code>extra = \"meta\"</code>)</li> </ul>"},{"location":"06-Caching-and-Syncing/#summary","title":"\u2705 Summary","text":"Command What it does <code>cosmos sync</code> Fetches <code>meta.toml</code> only <code>cosmos sync --stars</code> Fetches <code>meta.toml</code> + all <code>star.toml</code>s <code>cosmos sync --full</code> Fetches everything (meta, stars, tarballs) <code>cosmos install foo</code> Pulls star and package if missing <code>--offline</code> Fails if not already cached <p>Cosmos sync is fully user-controlled and deterministic. No guesswork. No magic. No network calls you didn\u2019t ask for.</p>"},{"location":"07-Flows/","title":"07 \u2013 Flows","text":"<p>This document outlines the core operational flows of the Cosmos package system, covering installation, uninstallation, updates, and syncing. Cosmos keeps behavior explicit and modular: CLI tools handle orchestration, while core libraries handle deterministic actions like installs and file tracking.</p>"},{"location":"07-Flows/#install-flow-cosmos-install-star","title":"\u2b06\ufe0f Install Flow (<code>cosmos install &lt;star&gt;</code>)","text":""},{"location":"07-Flows/#summary","title":"Summary:","text":"<p>Install a Star and its dependencies, supporting local or remote Galaxies, with optional offline mode.</p>"},{"location":"07-Flows/#steps","title":"Steps:","text":"<ol> <li>CLI loads system <code>config.toml</code> and current <code>universe.toml</code></li> <li>CLI loads all cached Galaxies (repositories)</li> <li>CLI searches for the requested Star across all Galaxies</li> <li>CLI selects the matching Galaxy + Star and passes it to <code>install_star()</code></li> <li>Core checks if the Star is already installed in the Universe</li> <li>Core resolves and installs dependencies recursively:</li> <li>Skip if already installed</li> <li>Otherwise, locate the dependency and install it the same way</li> <li>Core downloads the <code>.tar.gz</code> if needed (unless in offline mode)</li> <li>Core extracts the tarball to a temporary directory and runs the installation script (if any) from that location</li> <li>If there's no install script, it extracts <code>files/*</code> to the <code>install_root</code></li> <li>Core updates <code>universe.toml</code> with installed files</li> </ol>"},{"location":"07-Flows/#offline-mode","title":"\u26a1 Offline Mode","text":"<ul> <li><code>--offline</code> flag blocks any HTTP or file downloads</li> <li>If required files are missing from the cache or local repo, install fails</li> </ul>"},{"location":"07-Flows/#local-vs-remote-galaxies","title":"\ud83d\ude9c Local vs Remote Galaxies","text":"<ul> <li>Local Galaxies (e.g. <code>file:///</code> or mounted path): read directly from disk</li> <li>Remote Galaxies:</li> <li>By default, use <code>http://</code></li> <li>Additional protocols like <code>https://</code>, <code>ipfs://</code> require enabling optional features in the transport layer</li> </ul>"},{"location":"07-Flows/#dependency-resolution","title":"\ud83d\udd0d Dependency Resolution","text":"<ul> <li>Recursively installs each dependency</li> <li>Finds the first galaxy with a matching version of the required Star.</li> </ul>"},{"location":"07-Flows/#notes","title":"\u2728 Notes","text":"<ul> <li>Nebulae (meta Stars) are processed the same way but do not extract files or run scripts</li> <li>Dependencies are resolved by searching Galaxies in priority order, returning the first match that satisfies the constraint.</li> <li>CLI must ensure the target Star and Galaxy are found before calling core install</li> <li>Core handles everything after that: caching, extraction, install script, tracking</li> <li>Tarballs are always extracted to a temporary directory before installation; Nova scripts execute from this temp directory and install files into <code>install_root</code></li> </ul> <p>This split ensures the CLI can be customized per distro/environment, while the core logic stays portable, pure, and deterministic.</p>"},{"location":"07-Flows/#uninstall-flow-cosmos-uninstall-star","title":"\u274c Uninstall Flow (<code>cosmos uninstall &lt;star&gt;</code>)","text":""},{"location":"07-Flows/#summary_1","title":"Summary:","text":"<p>Remove a Star and its files from the system.</p>"},{"location":"07-Flows/#steps_1","title":"Steps:","text":"<ol> <li>Load system <code>config.toml</code> and <code>universe.toml</code></li> <li>Check if the Star is installed</li> <li>If not found, return an error</li> <li>Delete all recorded file paths</li> <li>Remove the Star entry from <code>universe.toml</code></li> </ol>"},{"location":"07-Flows/#notes_1","title":"Notes:","text":"<ul> <li>Cosmos does not track reverse dependencies</li> <li>If uninstall breaks another Star, that's on the user</li> <li>Nebulae uninstall instantly as they have no files</li> </ul>"},{"location":"07-Flows/#update-flow-cosmos-update-star","title":"\u21a9\ufe0f Update Flow (<code>cosmos update &lt;star&gt;</code>)","text":""},{"location":"07-Flows/#summary_2","title":"Summary:","text":"<p>Upgrade a Star if a newer version is available in any synced Galaxy.</p>"},{"location":"07-Flows/#steps_2","title":"Steps:","text":"<ol> <li>Load <code>universe.toml</code> and Galaxy cache</li> <li>Compare installed version to available versions</li> <li>If newer version matches semver constraints:<ol> <li>Uninstall the current version</li> <li>Install the new version via standard flow</li> </ol> </li> </ol>"},{"location":"07-Flows/#notes_2","title":"Notes:","text":"<ul> <li>If the Star is not installed, fallback to <code>install</code></li> <li>Cosmos does not automatically update all dependencies (manual per-Star)</li> <li>Future enhancement: <code>cosmos upgrade</code> to update all upgradable Stars</li> </ul>"},{"location":"07-Flows/#sync-flow-cosmos-sync","title":"\ud83e\uddf0 Sync Flow (<code>cosmos sync</code>)","text":""},{"location":"07-Flows/#summary_3","title":"Summary:","text":"<p>Download Galaxy metadata, Stars, and (optionally) packages to prepare for installation and offline use.</p>"},{"location":"07-Flows/#steps_3","title":"Steps:","text":"<ol> <li>Load <code>config.toml</code> and extract the <code>[galaxies]</code> table</li> <li>For each Galaxy:</li> <li>If the URL is local (<code>file://</code>, relative, or <code>/</code>) \u2192 skip</li> <li>If the URL is <code>https://</code> \u2192 abort unless Cosmos was built with TLS support</li> <li>Otherwise, download <code>meta.toml</code></li> <li>Depending on sync level:</li> <li><code>--stars</code>: download each listed <code>star.toml</code></li> <li><code>--full</code>: also download each tarball listed in its <code>source</code> field (if protocol supported)</li> <li>Store all results in <code>{cache_dir}/galaxies/&lt;name&gt;/</code></li> </ol>"},{"location":"07-Flows/#notes_3","title":"Notes:","text":"<ul> <li>Cosmos does not sync local/mounted Galaxies\u2014they are read directly</li> <li>TLS is not enabled by default; HTTP is supported out of the box</li> <li>Additional protocols are opt-in via the transport feature system</li> <li><code>meta.toml</code> must include a <code>[stars]</code> table with version strings</li> <li>Sync is one-shot and explicit\u2014no background updates, no auto-indexing</li> </ul> <p>These flows define the fundamental operations of Cosmos, emphasizing transparency, reproducibility, and total independence from external system dependencies.</p>"},{"location":"08-CLI/","title":"08 \u2013 Command Line Interface (CLI)","text":"<p>This document outlines the structure and design of the <code>cosmos</code> command-line interface. The CLI is designed to be minimal, explicit, and script-friendly, with no hidden behavior or runtime state.</p>"},{"location":"08-CLI/#philosophy","title":"\u2699\ufe0f Philosophy","text":"<ul> <li>Every command does one thing well</li> <li>No auto-updates or background syncs</li> <li>No dynamic linking, no TLS required by default</li> <li>Install flows are deterministic and offline-capable</li> </ul>"},{"location":"08-CLI/#command-overview","title":"\ufffd Command Overview","text":""},{"location":"08-CLI/#cosmos-install-star-offline-root-path","title":"<code>cosmos install &lt;star&gt; [--offline] [--root &lt;path&gt;]</code>","text":"<p>Installs a Star and its dependencies.</p> <ul> <li>Uses cached star and tarball if available</li> <li>Fetches missing files unless <code>--offline</code> is set</li> <li>Honors <code>--root</code> to install into a different root filesystem</li> <li>Skips extraction/scripts for Nebulae</li> </ul>"},{"location":"08-CLI/#cosmos-install-constellation-path-offline-root-path","title":"<code>cosmos install --constellation &lt;path&gt; [--offline] [--root &lt;path&gt;]</code>","text":"<p>Installs all Stars listed in a <code>constellation.toml</code>.</p> <ul> <li>Respects ordering</li> <li>Supports version pinning</li> <li>Same install rules as <code>install &lt;star&gt;</code></li> </ul>"},{"location":"08-CLI/#cosmos-uninstall-star-root-path","title":"<code>cosmos uninstall &lt;star&gt; [--root &lt;path&gt;]</code>","text":"<p>Uninstalls a Star by removing its tracked files.</p> <ul> <li>Pulls file list from <code>universe.toml</code></li> <li>Skips missing files with a warning</li> <li>Removes entry from universe</li> </ul>"},{"location":"08-CLI/#cosmos-status-root-path","title":"<code>cosmos status [--root &lt;path&gt;]</code>","text":"<p>Prints the list of installed Stars from <code>universe.toml</code>.</p> <ul> <li>Includes version numbers</li> <li>Future: add filtering/sorting</li> </ul>"},{"location":"08-CLI/#cosmos-sync-stars-full","title":"<code>cosmos sync [--stars] [--full]</code>","text":"<p>Downloads Galaxy metadata, Stars, and optional packages.</p> <ul> <li>Default: fetches <code>meta.toml</code> only</li> <li><code>--stars</code>: also fetches all <code>star.toml</code> files</li> <li><code>--full</code>: also fetches <code>.tar.gz</code> packages</li> <li>Skips local galaxies automatically</li> <li>HTTPS and other protocols require enabling transport features</li> </ul>"},{"location":"08-CLI/#cosmos-show-star","title":"<code>cosmos show &lt;star&gt;</code>","text":"<p>Prints the metadata for a given Star.</p> <ul> <li>Looks up in memory, cache, or fetches if needed</li> <li>Prints name, version, description, license, dependencies</li> </ul>"},{"location":"08-CLI/#cosmos-search-term","title":"<code>cosmos search &lt;term&gt;</code>","text":"<p>Searches across all loaded Galaxies.</p> <ul> <li>Matches against Star name and description</li> <li>Returns matching Star names</li> </ul>"},{"location":"08-CLI/#flags","title":"\ufffd Flags","text":"<ul> <li><code>--offline</code>: Disables any network calls or on-demand fetches</li> <li><code>--constellation &lt;file&gt;</code>: Install using a constellation file</li> <li><code>--root &lt;path&gt;</code>: Override install root (default is <code>/</code>)</li> <li><code>--stars</code>, <code>--full</code>: Optional flags for <code>sync</code></li> </ul>"},{"location":"08-CLI/#examples","title":"\ufffd Examples","text":"<pre><code>cosmos install zlib\ncosmos install --constellation ./presets/desktop.toml\ncosmos uninstall zlib\ncosmos status\ncosmos sync --stars\ncosmos show zlib\ncosmos search dev\n</code></pre>"},{"location":"08-CLI/#future-commands","title":"\ud83e\uddd8 Future Commands","text":"<ul> <li><code>verify &lt;star&gt;</code>: Validate files against tarball hash</li> <li><code>repair &lt;star&gt;</code>: Reinstall from cache without touching deps</li> <li><code>freeze</code>: Write a lockfile for reproducible reinstalls</li> </ul> <p>Cosmos CLI is intentionally boring: no shell magic, no YAML</p>"},{"location":"09-Tooling/","title":"09 \u2013 Tooling (Stellar)","text":"<p>This document defines the maintainer-side tooling that powers Cosmos package creation and validation. The tool is called Stellar, and it is used to create, build, verify, and lint Stars and Nebulae.</p>"},{"location":"09-Tooling/#what-is-stellar","title":"\u2728 What is Stellar?","text":"<p>Stellar is a CLI tool used by package authors and system maintainers. It performs tasks related to:</p> <ul> <li>Scaffolding new Stars</li> <li>Fetching remote sources for local builds</li> <li>Building package tarballs</li> <li>Running install logic (optionally using Nova)</li> <li>Validating dependencies</li> <li>Packaging and indexing for Galaxies</li> </ul> <p>Stellar is not required for using Cosmos\u2014only for building Stars and Galaxies.</p>"},{"location":"09-Tooling/#commands","title":"\ud83d\ude80 Commands","text":""},{"location":"09-Tooling/#stellar-new-star-name","title":"<code>stellar new-star &lt;name&gt;</code>","text":"<p>Scaffolds a new <code>star.toml</code> and optional build script.</p> <ul> <li>Prompts for version, description, type (normal/nebula)</li> <li>Creates folder with stub files and <code>files/</code> layout</li> </ul>"},{"location":"09-Tooling/#stellar-build-star-path","title":"<code>stellar build-star &lt;path&gt;</code>","text":"<p>Builds a <code>.tar.gz</code> of the Star using <code>star.toml</code></p> <ul> <li>Copies files into temp dir</li> <li>Includes optional <code>install.lua</code> Nova script if present</li> <li>Runs Nova script to prepare files (if needed) during build</li> <li>Outputs tarball in <code>./dist/</code> or configured output dir</li> <li>Produces a <code>.tar.gz</code> with the contents of <code>files/</code> and any <code>install.lua</code> script</li> </ul>"},{"location":"09-Tooling/#stellar-fetch-path","title":"<code>stellar fetch &lt;path&gt;</code>","text":"<p>Fetches the remote source defined in <code>star.toml</code> - Supports HTTP or local file URI (no Git yet) - Useful when a Star's <code>source</code> points to a raw upstream tarball - Downloads it for <code>build()</code> usage inside <code>install.lua</code> - Does not modify <code>star.toml</code> - Maintainer must later update <code>source</code> to the final tarball path post-build</p>"},{"location":"09-Tooling/#stellar-validate-path","title":"<code>stellar validate &lt;path&gt;</code>","text":"<p>Validates a star:</p> <ul> <li>Presence of required fields</li> <li>Correct semver and dependencies</li> <li>Script syntax (basic checks)</li> <li>Source URL accessibility (if specified)</li> <li>Ensures only one install script exists (<code>install.lua</code> or <code>install.sh</code>)</li> </ul>"},{"location":"09-Tooling/#stellar-lint-path-future","title":"<code>stellar lint &lt;path&gt;</code> (future)","text":"<p>Gives advice on naming conventions, doc clarity, and structure</p>"},{"location":"09-Tooling/#stellar-galaxy-init-name","title":"<code>stellar galaxy-init &lt;name&gt;</code>","text":"<p>Creates a new Galaxy repo with:</p> <ul> <li><code>meta.toml</code></li> <li><code>stars/</code> directory</li> <li><code>packages/</code> directory</li> </ul>"},{"location":"09-Tooling/#stellar-index-galaxy-path-future","title":"<code>stellar index-galaxy &lt;path&gt;</code> (future)","text":"<p>Generates/updates the <code>[stars]</code> table in <code>meta.toml</code></p> <ul> <li>Scans <code>stars/</code> for <code>.toml</code> files</li> <li>Extracts name + version</li> <li>Sorts and deduplicates entries</li> </ul>"},{"location":"09-Tooling/#example-workflow","title":"\ud83d\udd0d Example Workflow","text":"<pre><code>stellar new-star hello\n# edit files and install.lua...\nstellar fetch ./hello       # get source code\nstellar build-star ./hello  # run build() inside install.lua\nstellar validate ./hello\n# manually update star.toml source = \"file://...\"\n# copy tarball to core-galaxy/packages/\n</code></pre>"},{"location":"09-Tooling/#layout-and-defaults","title":"\ud83d\udcc2 Layout and Defaults","text":"<pre><code>stars/\n  zlib/\n    star.toml\n    install.lua\n    files/\n      usr/\n        include/\n        lib/\n</code></pre> <ul> <li><code>files/</code> is the root of what will be tarred</li> <li>Either <code>install.lua</code> (Nova script) or <code>install.sh</code> may be present, but Nova is preferred</li> <li>Only one should be used per package; <code>install.lua</code> is executed by Cosmos during install and should target <code>install_root</code></li> <li>If neither script is present, Cosmos defaults to copying <code>files/*</code></li> </ul>"},{"location":"09-Tooling/#future-features","title":"\ud83e\udd70 Future Features","text":"<ul> <li>Templates for common build systems (e.g. autotools, CMake, etc.)</li> <li>Nova scripting enhancements and validations</li> <li>Integration with <code>cosmos verify</code> for reproducible build hashing</li> </ul> <p>Stellar helps standardize package creation across all Galaxies and ensures a repeatable, minimal workflow.</p>"},{"location":"10-Nova/","title":"10 \u2013 Nova Scripting Engine","text":"<p>Nova gives Cosmos packages a portable, audit-friendly install logic system that works on any environment from Alpine to initramfs\u2014no Bash required.</p> <p>Nova is the optional, portable scripting engine for Cosmos. It is designed to replace shell-based <code>install_script</code> fields in <code>star.toml</code> with a safe, cross-platform alternative powered by Lua.</p> <p>Nova scripts should live within the tarball root directory and follow the standard install.lua + optional build() and install() functions format. Extra helpers are allowed, but all logic must be self-contained.</p> <p>Nova provides a constrained API surface tailored for packaging use cases: building, copying, and linking files during installation.</p> <p>Nova scripts are not standalone. They are invoked by Cosmos during install, with the runtime context passed in (e.g. real root path).</p>"},{"location":"10-Nova/#goals","title":"\ud83e\uddd1\u200d\ud83d\udcbb Goals","text":"<ul> <li>Replace raw shell scripts with safer, deterministic logic</li> <li>Avoid external interpreter dependencies (Nova is embedded)</li> <li>Allow packaging logic to be readable and portable</li> <li>Make error handling and file safety first-class citizens</li> </ul>"},{"location":"10-Nova/#core-principles","title":"\u2696\ufe0f Core Principles","text":"<ul> <li>Nova scripts are written in Lua 5.4+</li> <li>They are run inside a sandboxed Cosmos environment</li> <li>They do not have access to arbitrary system utilities (no <code>os.execute</code>)</li> <li>All filesystem operations are relative to the real root, which is passed by Cosmos</li> <li>Nova never decides where files go\u2014the package author does</li> </ul>"},{"location":"10-Nova/#basic-script-layout","title":"\ud83d\udcc4 Basic Script Layout","text":"<pre><code>function build()\n  run({\"make\"})\nend\n\nfunction install()\n  copy(\"bin/tool\", \"/usr/bin/tool\")\n  symlink(\"/usr/bin/tool\", \"/usr/bin/t\")\nend\n</code></pre>"},{"location":"10-Nova/#hello-world-example","title":"Hello World Example","text":"<pre><code>function install()\n  mkdir(\"/usr/share/hello\")\n  copy(\"hello.txt\", \"/usr/share/hello/hello.txt\")\nend\n</code></pre>"},{"location":"10-Nova/#runtime-environment","title":"\u2696\ufe0f Runtime Environment","text":"<p>Cosmos executes Nova scripts inside a controlled environment.</p>"},{"location":"10-Nova/#functions-provided","title":"Functions Provided:","text":""},{"location":"10-Nova/#runcommand-array-of-strings","title":"<code>run(command: array of strings)</code>","text":"<p>Runs a system command in the current working directory.</p> <ul> <li>Inherits stdout/stderr</li> <li>Returns exit code</li> <li>Raises error if non-zero</li> <li>Synchronous and blocks until completion</li> </ul> <p>Note: run() is powerful but unsafe. Use only for trusted build steps\u2014never run arbitrary commands from star input. <code>--safe</code> is an upcoming feature to disable the <code>run()</code> function.</p>"},{"location":"10-Nova/#copyfrom-string-to-string","title":"<code>copy(from: string, to: string)</code>","text":"<p>Copies a file from <code>from</code> (relative to working dir) to <code>to</code> (absolute path under real root).</p>"},{"location":"10-Nova/#symlinktarget-string-linkname-string","title":"<code>symlink(target: string, linkname: string)</code>","text":"<p>Creates a symlink from <code>linkname</code> to <code>target</code>, both rooted in the real root.</p>"},{"location":"10-Nova/#mkdirpath-string","title":"<code>mkdir(path: string)</code>","text":"<p>Creates a directory if it doesn't exist.</p>"},{"location":"10-Nova/#chmodpath-string-mode-number","title":"<code>chmod(path: string, mode: number)</code>","text":"<p>Sets file permissions (octal).</p>"},{"location":"10-Nova/#existspath-string","title":"<code>exists(path: string)</code>","text":"<p>Returns true if a file exists under real root.</p>"},{"location":"10-Nova/#root-behavior","title":"\ud83c\udfe0 Root Behavior","text":"<p>Cosmos will pass an install root path (e.g. <code>/</code>, or <code>/mnt/wombat-root</code>) to the Nova runtime. All file operations are resolved relative to this root, enforced internally.</p> <p>This enables:</p> <ul> <li>Real system installs</li> <li>Chroot builds</li> <li>Fake-root dry runs for package testing</li> </ul>"},{"location":"10-Nova/#error-handling","title":"\ud83e\udd16 Error Handling","text":"<ul> <li>Any failure in <code>run</code>, <code>copy</code>, etc. halts the script</li> <li>Cosmos will abort the install and clean up temp dirs</li> <li>Future: line numbers and error tracing for better debugging</li> </ul>"},{"location":"10-Nova/#future-features","title":"\ud83c\udf10 Future Features","text":"<ul> <li><code>env(key, value)</code>: set environment variables for future <code>run()</code> calls</li> <li><code>log()</code>: structured logging support</li> <li><code>filemap()</code>: declare expected outputs for validation</li> </ul> <p>Nova gives Cosmos packages a portable, audit-friendly install logic system that works on any environment from Alpine to initramfs\u2014no Bash required.</p>"},{"location":"10-Nova/#trust-safety-warning","title":"\u26a0\ufe0f Trust &amp; Safety Warning","text":"<p>Nova is sandboxed in spirit, not at the syscall level. It aims to provide a clean API and scoped file operations, but:</p> <ul> <li>run() executes real binaries on your system</li> <li>Nova does not chroot, isolate namespaces, or drop privileges</li> <li>Scripts can still execute destructive commands if written maliciously</li> <li><code>--safe</code> flag is an upcoming feature that disables <code>run()</code> and other unsafe operations</li> </ul>"},{"location":"11-Transport/","title":"11 \u2013 Transport Layer (cosmos-transport)","text":"<p>This document defines the purpose and structure of the <code>cosmos-transport</code> crate, which handles remote content fetching in a clean, modular, and Cosmos-aligned way.</p> <p><code>cosmos-transport</code> exists to provide network functionality without changing the trust model of Cosmos. All downloads are assumed to come from already-trusted sources.</p>"},{"location":"11-Transport/#what-is-cosmos-transport","title":"\ud83c\udf10 What is cosmos-transport?","text":"<p><code>cosmos-transport</code> is a standalone crate responsible for fetching remote content used by Cosmos. It handles:</p> <ul> <li>Downloading <code>.tar.gz</code> files during install</li> <li>Syncing Galaxy metadata over HTTP</li> <li>Optionally supporting alternative transports like HTTPS, FTP, or IPFS</li> </ul> <p>By isolating this logic, Cosmos remains modular, auditable, and easy to reason about.</p>"},{"location":"11-Transport/#core-philosophy","title":"\u2705 Core Philosophy","text":"<ul> <li>Transport is pluggable, not assumed</li> <li><code>cosmos-core</code> should not link any HTTP libraries directly</li> <li><code>cosmos-transport</code> is always compiled, but only minimal features are enabled by default</li> <li>HTTP is required and included by default</li> <li>HTTPS and TLS are optional features</li> <li>No background syncs, retries, or hidden redirects</li> </ul>"},{"location":"11-Transport/#what-lives-in-this-crate","title":"\ud83d\udce6 What Lives in This Crate?","text":""},{"location":"11-Transport/#current-behavior","title":"\u2705 Current Behavior:","text":"<ul> <li><code>fetch_bytes(url: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, TransportError&gt;</code></li> </ul> <p>Supports: - <code>http://</code> via <code>ureq</code> (enabled by default) - <code>https://</code> via <code>ureq/tls</code> (optional via feature flag)</p>"},{"location":"11-Transport/#not-included","title":"\u274c Not included:","text":"<ul> <li><code>file://</code> logic \u2013 handled in <code>cosmos-core</code></li> <li>Caching \u2013 handled elsewhere</li> <li>Mirrors \u2013 planned, not implemented</li> </ul>"},{"location":"11-Transport/#feature-flags","title":"\ud83d\udd27 Feature Flags","text":"<pre><code>[features]\ndefault = [\"http\"]\nhttp = [\"ureq\"]\ntls = [\"ureq/tls\"]\n</code></pre> <ul> <li><code>cosmos-transport</code> is always used by <code>cosmos-core</code></li> <li>Only the <code>http</code> feature is included by default</li> <li>The <code>https</code> capability must be enabled manually via the <code>transport-https</code> feature flag in <code>cosmos-core</code></li> </ul> <p>This design allows Cosmos to support remote access in constrained systems without requiring TLS, shared libraries, or complex network stacks. Future protocols can be implemented behind feature flags without affecting the trust model, performance, or predictability of the core system.</p>"},{"location":"12-FFI/","title":"12 \u2013 FFI Integration","text":"<p>This document describes the Foreign Function Interface (FFI) support in Cosmos. While Cosmos is written entirely in Rust, it supports optional C ABI exports for integration into non-Rust projects, C-based systems, or minimal userspace tooling.</p>"},{"location":"12-FFI/#ffi-philosophy","title":"\u2699\ufe0f FFI Philosophy","text":"<ul> <li>By default, the Cosmos ecosystem is pure Rust</li> <li>FFI is provided for external system tools or low-level integrations</li> <li>Headers are auto-generated using <code>cbindgen</code></li> <li>The <code>cosmos-core</code> crate can be built as a shared library (<code>cdylib</code>)</li> </ul>"},{"location":"12-FFI/#building-for-ffi","title":"\ud83d\udd27 Building for FFI","text":"<p>In <code>cosmos-core/Cargo.toml</code>:</p> <pre><code>[lib]\ncrate-type = [\"cdylib\"]\n</code></pre> <p>In your build command:</p> <pre><code>cargo build --release --lib\n</code></pre> <p>This will produce a <code>.so</code>, <code>.dylib</code>, or <code>.dll</code> depending on your platform.</p>"},{"location":"12-FFI/#header-generation-with-cbindgen","title":"\ud83d\udd2e Header Generation with cbindgen","text":"<p>To produce a C-compatible header:</p> <ol> <li>Add a <code>cbindgen.toml</code>:</li> </ol> <pre><code>[library]\ninclude-version = true\n[parse]\nparse_deps = false\n[output]\nlanguage = \"C\"\n</code></pre> <ol> <li>Run:</li> </ol> <pre><code>cbindgen --config cbindgen.toml --crate cosmos-core --output cosmos.h\n</code></pre>"},{"location":"12-FFI/#ffi-exports-planned","title":"\u2696\ufe0f FFI Exports (Planned)","text":"<pre><code>int cosmos_install(const char* star_name);\nint cosmos_uninstall(const char* star_name);\nint cosmos_update(const char* star_name);\nconst char* cosmos_last_error();\n</code></pre> <ul> <li>Errors are returned as codes, with optional access to <code>cosmos_last_error()</code> for string messages</li> <li><code>const char*</code> inputs are assumed to be UTF-8 null-terminated strings</li> </ul>"},{"location":"12-FFI/#use-cases","title":"\ud83c\udf10 Use Cases","text":"<ul> <li>Call Cosmos from a shell written in C</li> <li>Embed Cosmos into a microkernel userspace</li> <li>Integrate with FFI-compatible build systems or init tools</li> <li>Future: Cosmos TUI written in Zig or C could use the shared library</li> </ul>"},{"location":"12-FFI/#defaults","title":"\u2728 Defaults","text":"<ul> <li>Cosmos compiles as a regular Rust library by default</li> <li>FFI is opt-in via build and <code>#[no_mangle]</code> exports</li> <li>No impact on internal ecosystem structure</li> </ul> <p>FFI support ensures Cosmos can participate in truly minimal environments, including places where Rust is not the host language, while keeping the core ecosystem clean and fully idiomatic.</p>"},{"location":"13-Phase-3/","title":"13 \u2013 Phase 3 Features","text":"<p>This document outlines future enhancements and optional tools for Cosmos that go beyond the core system. These features are not required for the base install or use of Cosmos but are intended to expand its capabilities into a full OS ecosystem.</p>"},{"location":"13-Phase-3/#6-cosmosd-optional-daemon-later","title":"6. <code>cosmosd</code> (optional daemon, later)","text":"<p>A lightweight, event-driven daemon for automation and system tasks.</p>"},{"location":"13-Phase-3/#purpose","title":"Purpose:","text":"<ul> <li>Enable scheduled or triggered tasks without requiring a full init system</li> <li>Operate entirely opt-in and user-controlled</li> </ul>"},{"location":"13-Phase-3/#potential-features","title":"Potential Features:","text":"<ul> <li>Auto-update checker</li> <li>Background Galaxy sync and prefetching</li> <li>Trigger hooks on install/uninstall</li> <li>Optional D-Bus or UNIX socket interface for inter-process APIs</li> </ul>"},{"location":"13-Phase-3/#notes","title":"Notes:","text":"<ul> <li>Should never be required to use Cosmos</li> <li>Can run as a one-shot daemon or long-lived process depending on system</li> </ul>"},{"location":"13-Phase-3/#7-cosmos-ui-optional-tui-or-web-frontend-someday","title":"7. <code>cosmos-ui</code> (optional TUI or web frontend, someday)","text":"<p>A terminal interface for browsing and interacting with Cosmos.</p>"},{"location":"13-Phase-3/#tui-features","title":"TUI Features:","text":"<ul> <li>Package browser for installed Stars and synced Galaxies</li> <li>Show descriptions, versions, file lists</li> <li>Enable/disable installs, trigger updates, view diffs</li> <li>Keyboard-centric navigation</li> </ul>"},{"location":"13-Phase-3/#web-ui-future","title":"Web UI (future):","text":"<ul> <li>Read-only status display for server environments</li> <li>Could integrate with <code>cosmosd</code> as backend</li> </ul>"},{"location":"13-Phase-3/#tech-options","title":"Tech Options:","text":"<ul> <li>TUI: <code>ratatui</code> (Rust), <code>cursive</code></li> <li>Web: static export or minimal embedded HTTP server</li> </ul>"},{"location":"13-Phase-3/#8-cosmos-sdk-optional-shared-crate","title":"8. <code>cosmos-sdk</code> (optional shared crate)","text":"<p>Shared functionality for Cosmos-related tooling.</p>"},{"location":"13-Phase-3/#purpose_1","title":"Purpose:","text":"<ul> <li>Reduce duplicated code across CLI, Stellar, Nova</li> <li>Centralize logic that doesn't belong in <code>cosmos-core</code></li> </ul>"},{"location":"13-Phase-3/#common-modules","title":"Common Modules:","text":"<ul> <li>Logging and pretty output</li> <li>Config loading and validation</li> <li>Common errors, types, and file path handling</li> <li>Optional feature flags for ultra-minimal builds</li> </ul>"},{"location":"13-Phase-3/#9-cosmos-init-cosmos-bootstrap","title":"9. <code>cosmos-init</code> / <code>cosmos-bootstrap</code>","text":"<p>A bootstrap tool for building minimal systems using Cosmos from scratch.</p>"},{"location":"13-Phase-3/#purpose_2","title":"Purpose:","text":"<ul> <li>Install a working userland with only Cosmos and a base Galaxy</li> <li>Enable installation of Wombat Linux or similar musl-based systems</li> <li>Function inside an initramfs or rescue shell</li> </ul>"},{"location":"13-Phase-3/#features","title":"Features:","text":"<ul> <li>Unpack base system tarballs</li> <li>Resolve and install base Galaxy from local/remote source</li> <li>Can work without <code>/usr</code>, <code>/var</code>, or network</li> </ul>"},{"location":"13-Phase-3/#future-expansion","title":"Future Expansion:","text":"<ul> <li>Could become a full stage 0 \u2192 working userland bootstrapper</li> <li>Define full installation profiles for automated builds</li> </ul>"},{"location":"13-Phase-3/#10-cosmos-shell-integrated-nova-shell-runtime","title":"10. <code>cosmos-shell</code> (integrated Nova shell runtime)","text":"<p>A standalone shell-like interface for running Nova scripts interactively, performing system automation, and debugging installs.</p>"},{"location":"13-Phase-3/#purpose_3","title":"Purpose:","text":"<ul> <li>Allow Nova scripts to be run, tested, and explored interactively</li> <li>Provide a consistent scripting environment across install logic, test environments, and embedded tasks</li> <li>Serve as a programmable shell-like layer that works without traditional shell dependencies</li> </ul>"},{"location":"13-Phase-3/#features_1","title":"Features:","text":"<ul> <li>Launch an interactive Nova REPL (or CLI) for scripting</li> <li>Run Nova install scripts and system logic outside of install flow</li> <li>Inspect filesystem and configuration state</li> <li>Offer optional Nova extensions such as:</li> <li>Custom functions</li> <li>Built-in utilities</li> <li>Host/target-aware scripting</li> </ul>"},{"location":"13-Phase-3/#example","title":"Example:","text":"<pre><code>cosmos-shell\n&gt; run(\"mkdir -p /etc/cosmos\")\n&gt; copy(\"conf.toml\", \"/etc/cosmos/\")\n</code></pre>"},{"location":"13-Phase-3/#target-users","title":"Target Users:","text":"<ul> <li>Embedded developers</li> <li>Power users who want scripting without Bash</li> <li>System integrators and automation pipelines</li> </ul>"},{"location":"13-Phase-3/#notes_1","title":"Notes:","text":"<ul> <li>Not required to run packages</li> <li>Will integrate tightly with existing Nova runtime</li> <li>May support limited scripting extensions only available in <code>cosmos-shell</code></li> </ul>"},{"location":"13-Phase-3/#a-note-on-git-integration","title":"\ud83d\udd0d A Note on Git Integration","text":"<p>Cosmos will not use <code>libgit2</code>, shell out to <code>git</code>, or embed Git transport support.</p> <p>If you want to host Galaxies in Git:</p> <ul> <li>Clone them manually</li> <li>Serve them via raw HTTP or GitHub Pages</li> <li>Use Git to version content, but not to sync it</li> </ul> <p>Cosmos will not support <code>git://</code> as a protocol. You\u2019re in charge of your own sync strategy. No magic.</p>"},{"location":"13-Phase-3/#11-cosmos-utils-minimal-core-command-set","title":"11. <code>cosmos-utils</code> (minimal core command set)","text":"<p>A BusyBox-style bundle of essential CLI tools written in Rust, designed to be used inside minimal or recovery environments.</p>"},{"location":"13-Phase-3/#purpose_4","title":"Purpose:","text":"<ul> <li>Provide basic utilities (<code>ls</code>, <code>cp</code>, <code>rm</code>, <code>echo</code>, <code>mkdir</code>, etc.) for systems without BusyBox or coreutils</li> <li>Act as a lightweight fallback for file ops, inspection, and manual recovery</li> <li>Fully static and shell-free \u2014 complements Cosmos/Nova usage in rescue shells or initramfs</li> <li>Centralize low-level commands for future Cosmos bootstrapping tools</li> </ul>"},{"location":"13-Phase-3/#design-goals","title":"Design Goals:","text":"<ul> <li>Single binary with <code>argv[0]</code> dispatch (like BusyBox)</li> <li>Small, dependency-free Rust tools that mirror expected behavior</li> <li>Pretty, Cosmos-style output (errors, logs, confirmations)</li> <li>Built to integrate well with <code>nova</code> and <code>cosmos-bootstrap</code></li> </ul>"},{"location":"13-Phase-3/#example-commands","title":"Example Commands:","text":"<ul> <li><code>cosmos-utils ls</code> </li> <li><code>cosmos-utils cp</code> </li> <li><code>cosmos-utils echo</code> </li> <li><code>cosmos-utils rm</code> </li> <li><code>cosmos-utils mkdir</code> </li> <li>\u2026or use via symlink: <code>ls -&gt; cosmos-utils</code>, <code>rm -&gt; cosmos-utils</code></li> </ul>"},{"location":"13-Phase-3/#extras-optional","title":"Extras (Optional):","text":"<ul> <li>Dry-run mode for destructive ops (<code>--pretend</code>)</li> <li>Snarky or dry-humored warnings (if enabled)</li> <li>Nova helper integration (<code>nova shell</code>-safe)</li> </ul>"},{"location":"13-Phase-3/#future-expansion_1","title":"Future Expansion:","text":"<ul> <li>Include in Galaxy presets for recovery shells</li> <li>Optionally bundled into static rescue tarballs</li> <li><code>--coreutils</code> Cargo feature flag to include or exclude utilities as needed</li> </ul> <p>Cosmos-utils allows for fully shell-less systems with just Cosmos, Stellar, and Nova. Combined with <code>cosmos-bootstrap</code>, it enables entirely scriptable installs using only Cosmos-native tools.</p> <p>These Phase 3 tools support extending Cosmos from a tool into a platform\u2014one that is flexible enough for distros, embedded systems, recovery shells, or automation pipelines.</p> <p>Note: Nova is no longer a future feature. It is fully stable and integrated into Cosmos, with install scripts now defaulting to <code>install.lua</code> in most flows.</p>"},{"location":"14-Design-Rationale/","title":"14 \u2013 Design Rationale and Philosophy","text":"<p>This document explains the \"why\" behind key design decisions in Cosmos. It exists to clarify intentional tradeoffs and to serve as a personal or public reference when people ask, \"why didn't you just use X?\"</p> <p>TL;DR: Cosmos is a Rust-based, static, musl-first package manager designed to work when everything else breaks or when you deliberately don't want the rest of it. No Python. No Bash. No TLS required. If you can untar it, you can install it.</p> <p>Cosmos was built by someone who stared at a broken Linux install one too many times and thought:</p> <p>\"What if I could rebuild this entire system without Python, Bash, or crying?\"</p> <p>So here we are.</p> <p>Cosmos doesn\u2019t care about your desktop theme, your distro war, or your 14-layer init system. It cares about one thing:</p> <p>Can you install a working system using nothing but a static binary and a tarball?</p> <p>If yes, you win. If not, you probably ran something written in Python.</p> <p>But here's the twist:</p> <p>Cosmos also works when you're not in panic mode. It's just as happy living in an embedded system or on a purpose-built, no-frills Linux box.</p>"},{"location":"14-Design-Rationale/#why-not-apt-pacman-dnf-etc","title":"\ud83c\udf0c Why not APT, Pacman, DNF, etc?","text":"<p>These are built for desktops. Cosmos is built for bare metal and broken installs.</p> <p>Because those are built for general-purpose desktop Linux distributions. Cosmos is built for:</p> <ul> <li>Custom distros</li> <li>Initramfs environments</li> <li>Musl-based systems</li> <li>Fully static systems</li> <li>Recovery and self-repair tools</li> <li>Embedded and headless systems</li> </ul> <p>Those package managers rely on:</p> <ul> <li>Python</li> <li>Bash</li> <li>D-Bus</li> <li>TLS (and certificate chains)</li> <li>Dynamic linking</li> </ul> <p>Cosmos relies on:</p> <ul> <li>libc</li> </ul>"},{"location":"14-Design-Rationale/#why-not-shell-scripts","title":"\ud83e\udd84 Why not shell scripts?","text":"<p>Because shell scripts are quote mines and hell on wheels.</p> <p>Shell is powerful, but:</p> <ul> <li>Unsafe (every space or quote is a landmine)</li> <li>Unportable (dash vs bash vs busybox)</li> <li>Not predictable (subshells, environment leakage)</li> </ul> <p>Nova gives us:</p> <ul> <li>A safe, controlled scripting environment</li> <li>Cross-platform compatibility</li> <li>Clean separation of logic from shell quirks</li> <li>The ability to run even on embedded systems without needing a shell at all</li> </ul>"},{"location":"14-Design-Rationale/#why-rust","title":"\ud83d\ude80 Why Rust?","text":"<p>Because C is a land of undefined behavior and segfaults.</p> <ul> <li>No runtime</li> <li>No interpreter</li> <li>Memory safe</li> <li>Compiles to a static binary</li> <li>You can run Cosmos in an initramfs without libc quirks, dynamic libs, or runtime surprises</li> </ul> <p>Rust is a means to an end: predictable binaries that don't break when the system does.</p>"},{"location":"14-Design-Rationale/#why-no-https","title":"\u274c Why no HTTPS?","text":"<p>Because sometimes you just want to install a file without bringing half of OpenSSL with it.</p> <ul> <li>TLS requires runtime libs (OpenSSL, etc.)</li> <li>Certificates expire</li> <li>Embedded systems don\u2019t need encrypted package downloads</li> </ul> <p>Cosmos uses <code>http://</code> and <code>file://</code> by default. If you want HTTPS:</p> <ul> <li>Enable the <code>transport-https</code> feature in your build</li> <li>Use <code>cosmos-transport</code> to extend supported protocols</li> <li>Or mirror to USB, S3, or local filesystems</li> </ul> <p>This keeps the base lean while giving you control over the security model.</p>"},{"location":"14-Design-Rationale/#why-not-nix","title":"\u26a1 Why not Nix?","text":"<p>Because Nix is a black hole of complexity.</p> <p>Nix is brilliant, but also:</p> <ul> <li>Complex</li> <li>Immense</li> <li>Based on its own language and model</li> </ul> <p>Cosmos is not trying to do everything. It's trying to do the right thing at the right time.</p>"},{"location":"14-Design-Rationale/#why-toml","title":"\ud83d\udca1 Why TOML?","text":"<p>It parses predictably, it reads clean, and it won\u2019t gaslight you like YAML.</p> <ul> <li>Human-readable</li> <li>Easy to parse</li> <li>Less brittle than YAML</li> <li>More structured than JSON</li> <li>YAML is great for writing configs that never parse the same way twice.</li> </ul>"},{"location":"14-Design-Rationale/#why-modular-crates","title":"\u2705 Why modular crates?","text":"<p>So you can rip Cosmos apart and use it wherever you want.</p> <ul> <li>So you can embed Cosmos into anything</li> <li>So you can build your own TUI, API, init tool, or distro installer</li> <li>So Stellar, Nova, and the CLI don\u2019t step on each other</li> </ul>"},{"location":"14-Design-Rationale/#why-not-make-it-easier","title":"\u274c Why not make it easier?","text":"<p>Because this isn't for everyone\u2014it's for the ones left fixing systems at 3AM with nothing but tar and despair.</p> <p>It\u2019s not built for everyone. It\u2019s built for:</p> <ul> <li>Developers</li> <li>Tinkerers</li> <li>Custom OS builders</li> <li>People who need to fix a system with nothing but a tarball and a dream</li> <li>People who deploy Linux to tiny boxes with no runtime to spare</li> </ul> <p>Cosmos is not trying to be the easiest tool. It's trying to be the one that works when everything else breaks \u2014 or when nothing else belongs there in the first place.</p>"},{"location":"15-Security/","title":"15 \u2013 Security Model","text":"<p>Cosmos takes a pragmatic approach to security. It prioritizes simplicity, verifiability, and deterministic behavior over complex trust chains or opaque cryptographic systems. This document outlines the current and planned security considerations.</p> <p>Let\u2019s get something out of the way:</p> <p>If you\u2019re mad there's no required TLS, no GPG, and no certificate pinning, you might be looking for the wrong package manager.</p> <p>Cosmos is built for systems that are already trusted, constrained, or purpose-built. If you're bootstrapping from nothing or managing an offline system, TLS and GPG are often just extra ways for things to break.</p> <p>Instead, Cosmos gives you:</p> <ul> <li>Plain files</li> <li>Predictable layouts</li> <li>Auditable integrity</li> </ul> <p>Security is something you layer on if and when you need it.</p>"},{"location":"15-Security/#trust-model","title":"\ud83d\udd10 Trust Model","text":"<ul> <li>Trust is placed in the source of the Galaxy you sync</li> <li>Galaxies are expected to be hosted by trusted parties (e.g. your own USB, S3, HTTP mirror, or Git repo)</li> <li>There is no central verification authority</li> </ul>"},{"location":"15-Security/#no-tls-required-but-optional","title":"\u274c No TLS Required (But Optional)","text":"<ul> <li>Cosmos intentionally does not require HTTPS or OpenSSL</li> <li>This removes runtime SSL dependencies (libssl, cert bundles, etc.)</li> <li>Galaxies can be served from:</li> <li>Plain HTTP (default transport)</li> <li>USB drives</li> <li>File paths</li> <li>IPFS or Git (via optional transport features)</li> <li>HTTPS (if compiled with <code>transport-https</code> feature)</li> </ul> <p>If you want encrypted transport, you can use <code>scp</code>, <code>rsync</code>, <code>tailscale</code>, or enable TLS via the Cosmos transport layer.</p> <p>If you don\u2019t trust your Galaxy source, you have no security.</p> <p>You are responsible for trusting the transport medium.</p>"},{"location":"15-Security/#integrity","title":"\ufffd Integrity","text":"<ul> <li>Future: hashes of downloaded Star tarballs can be included in <code>star.toml</code></li> <li>Future: <code>cosmos verify</code> command will compare installed files to original tarball</li> <li>Future: <code>cosmos freeze</code> lockfiles will pin exact versions and hashes</li> </ul>"},{"location":"15-Security/#nova-safety","title":"\u2728 Nova Safety","text":"<ul> <li>Nova is a restricted Lua runtime designed to provide a safe API surface for install scripts. However, Nova does not prevent host escape if malicious scripts are written. It is sandboxed in spirit, not in syscall.</li> <li>All file ops go through Cosmos' internal API (e.g. <code>copy</code>, <code>run</code>, <code>symlink</code>)</li> <li>But <code>run()</code> executes real binaries on the real system</li> <li>All paths are forced under a real root prefix passed in by Cosmos</li> <li>If your script runs <code>rm -rf /</code>, that\u2019s on you</li> <li><code>--safe</code> flag is an upcoming feature that disables <code>run()</code> and other unsafe operations</li> </ul>"},{"location":"15-Security/#responsibility-statement","title":"\u26a0\ufe0f Responsibility Statement","text":"<p>Cosmos does not attempt to \"secure\" things with signatures or crypto if the system using it is already untrusted. Cosmos does not enforce privilege isolation. It does not chroot, drop privileges, or namespace-isolate builds.</p> <p>This philosophy mirrors tools like Alpine and Suckless:</p> <ul> <li>Auditable, human-readable scripts</li> <li>Encourage system owners to vet their inputs</li> <li>Minimal system dependencies</li> <li>Full transparency over runtime behavior</li> <li>Let users opt into higher security layers (signed hashes, reproducible builds) without mandating them</li> </ul>"},{"location":"15-Security/#future-ideas","title":"\ud83d\udee1\ufe0f Future Ideas","text":"<ul> <li>Optional GPG-signed <code>meta.toml</code></li> <li>Signed <code>universe.lock.toml</code> for immutable system reproducibility</li> <li>Support for hash pinning and binary transparency (optional, not core)</li> </ul> <p>Cosmos aims to be secure by design, not by bureaucracy.</p>"},{"location":"16-Examples/","title":"16 \u2013 Examples and Usage","text":"<p>This document provides step-by-step examples of how to use Cosmos in common real-world workflows. If you're the kind of person who skips all the theory and just wants to see what happens when you hit \"go,\" this one's for you.</p> <p>Cosmos won't hold your hand, but it will hand you a static binary and nod respectfully.</p>"},{"location":"16-Examples/#installing-a-single-star","title":"\ud83d\udd27 Installing a Single Star","text":"<pre><code>cosmos install zlib\n</code></pre> <ul> <li>Resolves dependencies</li> <li>Downloads tarball from synced Galaxy</li> <li>Runs install script or Nova (if defined)</li> <li>Updates <code>universe.toml</code></li> </ul> <p>It's like <code>apt</code>, except if it breaks, you can still uninstall it without praying to the Python gods.</p>"},{"location":"16-Examples/#installing-a-nebula","title":"\u2728 Installing a Nebula","text":"<pre><code>cosmos install dev-base\n</code></pre> <p>Where <code>dev-base.star.toml</code>:</p> <pre><code>name = \"dev-base\"\ntype = \"nebula\"\n\n[dependencies]\nzlib = \"&gt;=1.2\"\nbusybox = \"^1.36\"\ngcc = \"^13\"\n</code></pre> <p>Installs all dependencies, installs nothing directly. It exists purely to summon other Stars.</p>"},{"location":"16-Examples/#installing-a-constellation","title":"\ud83d\ude80 Installing a Constellation","text":"<pre><code>cosmos install --constellation ./constellations/desktop.toml\n</code></pre> <p>Contents:</p> <pre><code>name = \"desktop\"\ndescription = \"Desktop environment\"\nmembers = [\n  \"xorg\",\n  \"firefox\",\n  \"alacritty\"\n]\n</code></pre> <p>Installs listed Stars in order. Skips any already installed. No fluff.</p>"},{"location":"16-Examples/#building-a-star-with-stellar","title":"\ud83e\udd3a Building a Star with Stellar","text":"<pre><code>stellar new-star hello-world\n# edit files/star.toml and add files/\nstellar build-star ./hello-world\n</code></pre> <p>Creates <code>./dist/hello-world-1.0.0.tar.gz</code>. If it breaks, check your paths. And your soul.</p>"},{"location":"16-Examples/#nova-script-example","title":"\ud83e\udd14 Nova Script Example","text":"<pre><code>function build()\n  run(\"make\")\nend\n\nfunction install()\n  copy(\"bin/tool\", \"/usr/bin/tool\")\n  symlink(\"/usr/bin/tool\", \"/usr/bin/t\")\nend\n</code></pre> <p>Nova doesn\u2019t care about your shell aliases. It just wants to copy files and go home.</p>"},{"location":"16-Examples/#offline-install-from-usb","title":"\ud83e\udd16 Offline Install from USB","text":"<pre><code># Sync Galaxy from USB\ncosmos sync --from file:///mnt/usb/galaxies/core\n\n# Install normally from cache\ncosmos install busybox\n</code></pre> <p>No internet. No Python. No excuses.</p> <p>These examples show how Cosmos can be used both interactively and in scripting or automation workflows. Its minimalism enables usage in embedded systems, recovery shells, or fully custom distros. And when the world ends, you'll still be able to install zlib.</p>"},{"location":"17-FAQ/","title":"17 - Frequently Asked Questions (FAQ)","text":""},{"location":"17-FAQ/#why-does-cosmos-link-to-libmso6-and-libgcc_sso1-on-glibc","title":"\ud83e\udd14 Why does Cosmos link to <code>libm.so.6</code> and <code>libgcc_s.so.1</code> on glibc?","text":"<p>This is normal and expected behavior on glibc-based systems.</p> <p>Cosmos is designed to be as lightweight and portable as possible. When compiled for glibc, it dynamically links to:</p> <ul> <li><code>libc.so.6</code>: the GNU C library (standard)</li> <li><code>libm.so.6</code>: the math library</li> <li><code>libgcc_s.so.1</code>: GCC support library</li> </ul> <p>These are all part of a standard glibc runtime environment and are available on every major Linux distribution.</p>"},{"location":"17-FAQ/#why-is-libm-needed","title":"\ud83d\udd27 Why is <code>libm</code> needed?","text":"<p>Cosmos uses the <code>flate2</code> crate to handle <code>.tar.gz</code> package extraction. Internally, this crate (or one of its dependencies) performs basic math operations like floating-point multiplication. On glibc, these are handled by <code>libm</code> instead of inlining or statically linking them.</p>"},{"location":"17-FAQ/#why-is-libgcc_sso1-required","title":"\ud83c\udf0c Why is <code>libgcc_s.so.1</code> required?","text":"<p>This comes from the Rust compiler toolchain, which depends on certain runtime support features provided by GCC's libgcc. This includes things like stack unwinding and low-level math operations.</p> <p>Unless you're using a custom toolchain, libgcc is already included on all glibc-based systems.</p>"},{"location":"17-FAQ/#what-about-musl-builds","title":"\ud83d\ude80 What about musl builds?","text":"<p>If you build Cosmos using the musl target, the result is a:</p> <ul> <li>Fully static binary</li> <li>No dynamic dependencies</li> <li>Compatible with initramfs, containers, and minimalist distros</li> </ul> <p>You can build it like this:</p> <pre><code>rustup target add x86_64-unknown-linux-musl\ncargo build --release --target x86_64-unknown-linux-musl\n</code></pre> <p>Then run <code>ldd</code> on the result:</p> <pre><code>$ ldd cosmos\n# should only reference the libc library\n# something like this:\nlinux-vdso.so.1 =&gt;  (0x00007fffdc3f7000)\n</code></pre>"},{"location":"17-FAQ/#isnt-this-a-security-concern","title":"\ud83d\udca5 Isn't this a security concern?","text":"<p>Only if your threat model includes floating-point arithmetic and basic division.</p> <p>Linking to <code>libm</code> and <code>libgcc</code> is completely standard for glibc builds. If you require complete static linking for security, reproducibility, or environment constraints, we recommend using the musl build.</p>"},{"location":"17-FAQ/#summary","title":"\u2705 Summary","text":"Target Static? Linked Libraries <code>glibc</code> No <code>libc</code>, <code>libm</code>, <code>libgcc</code> <code>musl</code> Yes None (fully static) <p>Cosmos is built offline-first and is functional in both environments. Your math still works. Your packages still install. Your system is still safe.</p> <p>You're fine.</p>"},{"location":"17-FAQ/#what-if-i-want-to-strip-cosmos-down-even-more","title":"\ud83e\uddf1 What if I want to strip Cosmos down even more?","text":"<p>Set this in <code>.cargo/config.toml</code>:</p> <pre><code>[profile.release]\npanic = \"abort\"\n</code></pre> <p>This can remove <code>libgcc_s.so.1</code> from glibc builds. Use <code>strip</code> to remove debug symbols and reduce size:</p> <pre><code>strip ./target/release/cosmos-cli\n</code></pre>"},{"location":"17-FAQ/#how-small-can-the-binary-get","title":"\ufffd How small can the binary get?","text":"<p>With a musl static build + stripping, Cosmos CLI can be under 4 MB, even with Nova embedded. Most installs will work offline and fit in a bootable initramfs.</p>"},{"location":"17-FAQ/#why-not-use-tls-or-gpg","title":"\ud83e\uddea Why not use TLS or GPG?","text":"<p>Cosmos does not require TLS, GPG, or any central trust mechanism.</p> <p>Instead, you\u2019re expected to:</p> <ul> <li>Host Galaxies from trusted sources (USB, internal HTTP, S3)</li> <li>Manually verify what you install</li> <li>Use <code>cosmos freeze</code> (coming soon) for lockfile verification</li> </ul> <p>TLS can be enabled via the <code>transport-https</code> feature. By default, only <code>http://</code> and <code>file://</code> are supported.</p> <p>See the Security Model for full rationale.</p>"},{"location":"17-FAQ/#why-is-everything-named-after-space-stuff","title":"\ud83d\udcad Why is everything named after space stuff?","text":"<p>Because it\u2019s internally consistent, poetic, and structurally accurate:</p> <ul> <li>Cosmos = the full system</li> <li>Galaxies = repositories</li> <li>Stars = packages</li> <li>Nebulae = meta-packages</li> <li>Constellations = install presets</li> <li>Universe = installed state</li> <li>Nova = installer scripting engine</li> </ul> <p>It sounds fun, but it actually makes the entire system easy to reason about. You don\u2019t need to memorize terminology. You just need to understand space.</p>"},{"location":"17-FAQ/#can-i-use-cosmos-in-my-initramfs-or-rescue-usb","title":"\ud83d\udc1a Can I use Cosmos in my initramfs or rescue USB?","text":"<p>Absolutely. That\u2019s what it\u2019s built for.</p> <p>The entire system is designed to: - Be static (especially with musl) - Work offline - Install to any rootfs - Run without Python, Bash, or shared libraries</p> <p>If you can boot a shell and run a binary, you can use Cosmos.</p>"},{"location":"17-FAQ/#does-cosmos-do-dependency-resolution","title":"\ud83e\uddea Does Cosmos do dependency resolution?","text":"<p>Yes \u2014 minimal and predictable.</p> <ul> <li>Uses semver-style constraints defined in <code>star.toml</code></li> <li>Resolves across configured Galaxies in order</li> <li>Does not re-resolve dependencies on update</li> <li>No graph solving, no \u201cintelligent\u201d magic</li> </ul> <p>You get reproducibility over reactivity.</p>"},{"location":"17-FAQ/#whats-the-difference-between-stars-nebulae-and-constellations","title":"\ud83e\udde0 What\u2019s the difference between Stars, Nebulae, and Constellations?","text":"Type Purpose Star A package (with tarball and install logic) Nebula A dependency-only meta-package Constellation A user-defined install preset <p>Nebulae have no install script or files \u2014 they just express dependencies. Constellations are external TOML presets, not tracked in the system state.</p>"},{"location":"17-FAQ/#where-is-the-package-database","title":"\ud83d\udd0d Where is the package database?","text":"<p>There isn\u2019t one. Cosmos tracks installs using a plain TOML file: <code>universe.toml</code>.</p> <p>It logs: - Installed Stars - Their versions - Their installed file paths</p> <p>You can inspect it, edit it, back it up, and diff it manually. No SQLite, no JSON soup, no binary blobs.</p>"},{"location":"17-FAQ/#what-if-i-want-to-contribute-a-faq-question","title":"\ud83d\udc7d What if I want to contribute a FAQ question?","text":"<p>PRs welcome. Especially sarcastic ones.</p>"},{"location":"18-Galaxies/","title":"18 \u2013 Galaxies","text":"<p>Galaxies are where Stars go to live (or die). A Galaxy in Cosmos is a plain folder that contains:</p> <ul> <li>A <code>meta.toml</code> file with basic info</li> <li>A list of available Star packages</li> <li>An optional <code>/packages/</code> directory full of compressed tarballs</li> <li>A <code>/stars/</code> directory full of individual <code>star.toml</code> files</li> </ul> <p>Galaxies are designed to be as dumb and static as possible\u2014because the smartest systems are the ones that survive a power outage.</p>"},{"location":"18-Galaxies/#example-metatoml","title":"\ufffd Example <code>meta.toml</code>","text":"<pre><code>name = \"core\"\ndescription = \"Core packages for Cosmos systems\"\nversion = \"2024.04.17\"\n[stars]\nmusl = \"1.2.4\"\nbusybox = \"1.36.0\"\nzlib = \"1.2.13\"\n</code></pre> <p>Yes, that's all it takes. Cosmos doesn't need a daemon, indexer, or full-time YAML whisperer to read this. Just serve it statically.</p>"},{"location":"18-Galaxies/#example-directory-layout","title":"\ud83d\udd00 Example Directory Layout","text":"<pre><code>https://mirror.example.org/galaxies/core/\n\u251c\u2500\u2500 meta.toml\n\u251c\u2500\u2500 stars/\n\u2502   \u251c\u2500\u2500 musl.toml\n\u2502   \u251c\u2500\u2500 busybox.toml\n\u2502   \u251c\u2500\u2500 zlib.toml\n\u2502   \u2514\u2500\u2500 cosmos-cli.toml\n\u2514\u2500\u2500 packages/\n    \u251c\u2500\u2500 musl-1.2.4.tar.gz\n    \u251c\u2500\u2500 busybox-1.36.0.tar.gz\n    \u2514\u2500\u2500 zlib-1.2.13.tar.gz\n</code></pre> <p>This can be served from:</p> <ul> <li>S3</li> <li>GitHub Pages</li> <li>Your personal server</li> <li>A USB stick you found in a drawer from 2008</li> <li>A Git repo you cloned manually (Cosmos will never do this for you)</li> <li>Any HTTP/HTTPS endpoint (HTTPS requires the optional transport feature)</li> </ul>"},{"location":"18-Galaxies/#rules-of-hosting-a-galaxy","title":"\u274c Rules of Hosting a Galaxy","text":"<p>Managing a Galaxy sounds cool until you realize it means:</p> <ul> <li>Maintaining packages regularly</li> <li>Keeping <code>meta.toml</code> in sync with the actual contents</li> <li>Testing packages so they don\u2019t destroy someone\u2019s root directory</li> <li>Updating checksums when you change a tarball</li> <li>Being up 24/7 if others depend on it</li> </ul> <p>You break it? You bought it.</p> <p>If you're not ready to maintain your own galaxy, don't. Use someone else's. Fork one. Remix one. Or go build Stars and let someone else host them.</p>"},{"location":"18-Galaxies/#the-official-galaxy","title":"\ud83c\udf0c The Official Galaxy","text":"<p>If Cosmos ever gets an official Galaxy, it will probably be hosted on:</p> <ul> <li>S3 or a static file server</li> <li>With no TLS by default</li> <li>With a massive readme warning you not to blindly trust it</li> </ul> <p>This is because Cosmos believes in:</p> <ul> <li>Simplicity</li> <li>Reproducibility</li> <li>You being responsible for your own system</li> </ul> <p>(And yes, TLS can be enabled if you build with <code>transport-https</code>.)</p>"},{"location":"18-Galaxies/#final-notes","title":"\ud83c\udf0a Final Notes","text":"<p>Galaxies are boring by design. That makes them reliable. If it can't be served over <code>python3 -m http.server</code>, it's probably too complicated.</p>"},{"location":"18-Galaxies/#about-git","title":"\ud83d\udd0d About Git","text":"<p>If you want to use Git, that\u2019s fine\u2014clone the Galaxy yourself. Cosmos doesn't use <code>git clone</code>, <code>libgit2</code>, or any other dynamic Git transport. Serve the raw files, or keep them local. No Git magic here.</p> <p>Remember: if Git can host your entire repo, it can probably host your entire Galaxy.</p> <p>Cosmos doesn't care what you host on\u2014just that it works.</p>"},{"location":"19-Versioning/","title":"19 \u2013 Versioning and Release Policy","text":"<p>This document defines the versioning strategy for Cosmos Stars, Galaxies, and the overall ecosystem. It also outlines how packages should be updated, deprecated, or removed.</p>"},{"location":"19-Versioning/#versioning-philosophy","title":"\ud83d\udd04 Versioning Philosophy","text":"<ul> <li>Stars follow SemVer (<code>major.minor.patch</code>)</li> <li>Galaxies are versioned by date (<code>YYYY.MM.DD</code>, e.g., <code>2024.04.17</code>)</li> <li>Cosmos itself will follow SemVer but moves slowly</li> </ul> <p>Versioning exists for clarity and reproducibility, not hype. If nothing changed, the version doesn't change.</p>"},{"location":"19-Versioning/#star-versioning","title":"\u2728 Star Versioning","text":"<p>Every Star must define:</p> <pre><code>version = \"1.2.3\"\n</code></pre> <ul> <li>Stars are expected to follow SemVer</li> <li>Breaking changes to install logic = major bump</li> <li>Dependency changes = minor bump</li> <li>Tarball rebuild or checksum-only = patch bump</li> </ul> <p>New versions must be uploaded with updated filenames:</p> <pre><code>zlib-1.2.3.tar.gz\n</code></pre> <p>Old versions may be kept for compatibility.</p>"},{"location":"19-Versioning/#galaxy-versioning","title":"\ud83c\udf0c Galaxy Versioning","text":"<p>Each Galaxy has a <code>meta.toml</code> with:</p> <pre><code>version = \"2024.04.17\"\n</code></pre> <p>This version is used for:</p> <ul> <li>Identifying sync points</li> <li>Snapshotting a full system state</li> <li>Reference in freeze/lockfile scenarios</li> </ul> <p>Preferred format: <code>YYYY.MM.DD</code> for clarity and traceability</p> <ul> <li>Easy to sort</li> <li>Helps with security updates or multiple changes in a month</li> </ul> <p>Galaxies must update <code>meta.toml</code> if any of the following change:</p> <ul> <li>New Star added</li> <li>Existing Star updated</li> <li>Any Star removed</li> </ul>"},{"location":"19-Versioning/#galaxy-archival-recommended","title":"\ud83d\udd04 Galaxy Archival (Recommended)","text":"<ul> <li>It is not required to archive every Galaxy version</li> <li>However, maintainers are strongly encouraged to retain the past 3\u20136 months of Galaxy snapshots</li> <li>For long-term reproducibility (e.g., distro builds), consider archiving stable versions annually</li> <li>Rolling releases can prune aggressively, but should still tag known good versions</li> </ul> <p>Ultimately, archival policies are up to the maintainer. Cosmos recommends preserving history, but does not enforce it.</p>"},{"location":"19-Versioning/#constellation-stability","title":"\ud83c\udf0d Constellation Stability","text":"<p>Constellations are install presets. If a Constellation references Stars that change, that's fine\u2014but users should be encouraged to:</p> <ul> <li>Pin Constellation files to Galaxy versions</li> <li>Create locked snapshots of their system after install</li> </ul> <p>Example:</p> <pre><code>members = [\n  \"core-utils@1.0.0\",\n  \"busybox@1.36.0\"\n]\n</code></pre> <p>Version pinning is optional but strongly encouraged for reproducibility.</p>"},{"location":"19-Versioning/#deprecation-and-removal","title":"\u274c Deprecation and Removal","text":""},{"location":"19-Versioning/#stars","title":"Stars:","text":"<ul> <li>Deprecated Stars should remain in the Galaxy but clearly marked in <code>description</code></li> <li>Removed Stars must be deleted from <code>stars/</code> and <code>packages/</code> but remain listed in old Galaxy versions</li> </ul>"},{"location":"19-Versioning/#galaxies","title":"Galaxies:","text":"<ul> <li>Galaxies are never deleted, only archived with new versions (if the maintainer chooses to)</li> <li>The latest version is expected to be symlinked or aliased in mirrors</li> </ul>"},{"location":"19-Versioning/#release-recommendations","title":"\ud83d\udd16 Release Recommendations","text":"<ul> <li>Use Git tags for Galaxy releases (<code>core-2024.04.17</code>)</li> <li>Use signed commits if hosting public Galaxies</li> <li>Tarballs should include version in filename</li> <li>Include changelogs if maintaining official sets</li> </ul> <p>Versioning is about trust and stability, not chasing numbers. Cosmos prefers boring, explicit, and stable packages over rapid churn.</p>"},{"location":"20-Cosmos-Contribution/","title":"20 \u2013 Contributing to Cosmos (Project Guidelines)","text":"<p>This guide is for contributors to the Cosmos codebase itself\u2014including <code>cosmos-core</code>, <code>cosmos-cli</code>, <code>stellar</code>, <code>nova</code>, and related tooling.</p>"},{"location":"20-Cosmos-Contribution/#project-philosophy","title":"\ud83d\udee0\ufe0f Project Philosophy","text":"<ul> <li>Cosmos is modular, minimal, and predictable</li> <li>Contributions should avoid feature bloat or scope creep</li> <li>Every crate should do one thing well and be testable in isolation</li> </ul>"},{"location":"20-Cosmos-Contribution/#getting-started","title":"\ud83c\udf93 Getting Started","text":"<ol> <li>Clone the repo</li> <li>Use the latest stable Rust (<code>rustup update</code>)</li> <li>Build the workspace:    <code>bash    cargo build --workspace</code></li> <li>Run all tests:    <code>bash    cargo test --workspace</code></li> <li>Optional: install <code>cargo-make</code> or <code>just</code> if you're using task runners</li> </ol>"},{"location":"20-Cosmos-Contribution/#code-guidelines","title":"\ud83d\udd28 Code Guidelines","text":"<ul> <li>Follow Rust 2021 edition idioms</li> <li>Use <code>thiserror</code> for error enums</li> <li>Favor <code>Result&lt;T, CosmosError&gt;</code> over panics</li> <li>Don\u2019t use <code>unwrap()</code> unless you really mean it</li> <li>All FFI functions must be <code>#[no_mangle]</code> and use C types</li> </ul>"},{"location":"20-Cosmos-Contribution/#pull-requests","title":"\ud83d\udd04 Pull Requests","text":"<ul> <li>One logical change per PR</li> <li>PR title should summarize purpose</li> <li>Document new CLI commands, options, or config fields</li> <li>Include tests where applicable</li> <li>Update relevant markdown docs in <code>/docs</code></li> </ul>"},{"location":"20-Cosmos-Contribution/#feature-flags","title":"\ud83d\udcca Feature Flags","text":"<ul> <li>Use <code>#[cfg(feature = \"ffi\")]</code> for optional components</li> <li>Don\u2019t enable features by default unless essential</li> </ul>"},{"location":"20-Cosmos-Contribution/#docs-and-comments","title":"\u270f\ufe0f Docs and Comments","text":"<ul> <li>Public functions should have doc comments</li> <li>Internal helpers can use line comments for clarity</li> <li>Markdown docs should be updated when adding major features</li> </ul>"},{"location":"20-Cosmos-Contribution/#licensing-and-attribution","title":"\ud83c\udf10 Licensing and Attribution","text":"<ul> <li>All contributions are MIT licensed</li> <li>Add your name to the AUTHORS file if you wish</li> <li>Respect the project's tone: technical, clear, with dry humor allowed</li> </ul>"},{"location":"20-Cosmos-Contribution/#where-to-help","title":"\ud83c\udf1f Where to Help","text":"<ul> <li>Finish Nova runtime logic</li> <li>Improve dependency resolution logic</li> <li>Add <code>stellar lint</code> / <code>stellar test</code> features</li> <li>Write sample Stars for testing and examples</li> <li>Write CLI integration tests</li> </ul> <p>Cosmos is built for clarity and longevity. Contributions that make it more robust, understandable, and portable are always welcome.</p>"},{"location":"21-Contribution-Guide-for-Maintainers/","title":"21 \u2013 Maintaining Galaxies and Stars","text":"<p>This guide is for maintainers of Cosmos Galaxies and package authors who want to build Stars (or Nebulae) that others can install.</p>"},{"location":"21-Contribution-Guide-for-Maintainers/#your-responsibilities","title":"\ud83c\udf1f Your Responsibilities","text":"<p>If you're maintaining a Galaxy or publishing Stars, you are expected to:</p> <ul> <li>Keep <code>meta.toml</code> up to date (names, versions, descriptions, star list)</li> <li>Update or rebuild tarballs when package contents change</li> <li>Recalculate checksums if hashes are implemented</li> <li>Test packages before publishing them (install + uninstall)</li> <li>Use SemVer responsibly for Star versioning</li> <li>Use <code>YYYY.MM.DD</code> format for Galaxy versions in <code>meta.toml</code></li> <li>Consider archiving versions of your Galaxy for long-term reproducibility (3\u20136 months minimum is recommended)</li> </ul> <p>If that sounds like a lot of work\u2014it is. Cosmos assumes you take ownership seriously.</p>"},{"location":"21-Contribution-Guide-for-Maintainers/#creating-a-star","title":"\u2699\ufe0f Creating a Star","text":"<p>Use <code>stellar new-star &lt;name&gt;</code> to scaffold a new package:</p> <ul> <li>Edit <code>star.toml</code> to define name, version, and dependencies</li> <li>Add an <code>install.sh</code> or <code>nova.lua</code> script</li> <li>Place files in a <code>files/</code> directory relative to the star</li> </ul> <p>Then:</p> <pre><code>stellar build-star ./your-package\n</code></pre> <p>This creates a <code>.tar.gz</code> that installs under Cosmos.</p>"},{"location":"21-Contribution-Guide-for-Maintainers/#making-a-nebula","title":"\u2728 Making a Nebula","text":"<p>A Nebula is a dependency-only Star:</p> <pre><code>name = \"core-stack\"\ntype = \"nebula\"\nversion = \"1.0.0\"\n\n[dependencies]\nmusl = \"^1.2.4\"\nbusybox = \"^1.36\"\n</code></pre> <p>Nebulae should have no <code>source</code>, no <code>install_script</code>, and no <code>files/</code>.</p>"},{"location":"21-Contribution-Guide-for-Maintainers/#structuring-a-galaxy","title":"\ud83d\udcc4 Structuring a Galaxy","text":"<pre><code># meta.toml\nname = \"core\"\ndescription = \"Minimal bootable stack\"\nversion = \"2024.04.17\"\nstars = [\"musl\", \"busybox\", \"zlib\"]\n</code></pre> <pre><code>core-galaxy/\n\u251c\u2500\u2500 meta.toml\n\u251c\u2500\u2500 stars/\n\u2502   \u251c\u2500\u2500 musl.toml\n\u2502   \u251c\u2500\u2500 busybox.toml\n\u2502   \u2514\u2500\u2500 zlib.toml\n\u251c\u2500\u2500 packages/\n\u2502   \u251c\u2500\u2500 musl-1.2.4.tar.gz\n\u2502   \u2514\u2500\u2500 busybox-1.36.0.tar.gz\n</code></pre> <p>You can host this via:</p> <ul> <li>S3 (static file bucket)</li> <li>GitHub Pages</li> <li>Any static HTTP server</li> <li>A USB stick you left plugged in since last fall</li> </ul>"},{"location":"21-Contribution-Guide-for-Maintainers/#common-mistakes","title":"\u274c Common Mistakes","text":"<ul> <li>Forgetting to bump versions after a change</li> <li>Publishing a tarball with the wrong contents</li> <li>Mismatching star name vs filename</li> <li>Forgetting to update <code>meta.toml</code></li> <li>Publishing a Galaxy without testing anything</li> </ul> <p>Cosmos won\u2019t stop you. But it will laugh quietly when your Galaxy breaks.</p>"},{"location":"21-Contribution-Guide-for-Maintainers/#release-checklist","title":"\ud83d\ude80 Release Checklist","text":"<ul> <li>[ ] Does every Star have a valid <code>star.toml</code>?</li> <li>[ ] Are the tarballs named correctly?</li> <li>[ ] Is <code>meta.toml</code> version bumped?</li> <li>[ ] Are dependencies valid?</li> <li>[ ] Can everything install cleanly with no internet?</li> <li>[ ] Has this Galaxy been archived or tagged in Git for historical reference?</li> </ul> <p>If yes: congratulations. You made a Galaxy.</p> <p>If no: go fix it before someone files a bug at 3AM.</p>"},{"location":"21-Contribution-Guide-for-Maintainers/#publishing-and-hosting-tips","title":"\ud83e\udd16 Publishing and Hosting Tips","text":"<ul> <li>Use Git tags for Galaxy versions (<code>core-2024.04.17</code>)</li> <li>Pin Galaxy metadata to specific Star versions</li> <li>Use symlinks for \"latest\"</li> <li>Mirror Galaxies to USB, IPFS, Git, or whatever works for your threat model</li> </ul> <p>Maintaining Galaxies is an act of service. Do it well, or don\u2019t do it at all.</p>"},{"location":"22-Crate-Policy/","title":"22 \u2013 Crate Policy","text":"<p>Cosmos is built to run in minimal, musl-based, interpreter-free environments with zero dynamic linking. This document defines what crates are allowed and what constraints they must follow to be included in the Cosmos ecosystem.</p>"},{"location":"22-Crate-Policy/#build-target-philosophy","title":"\ud83e\uddf1 Build Target Philosophy","text":"<ul> <li>musl-first, libc-agnostic</li> <li>If Rust can target it, Cosmos should build on it</li> <li>All code must build with just <code>cargo build --release</code></li> <li>No external build systems, no <code>make</code>, no <code>pkg-config</code>, no <code>cc</code> crates</li> </ul>"},{"location":"22-Crate-Policy/#allowed-crate-behavior","title":"\u2705 Allowed Crate Behavior","text":"<p>All crates must:</p> <ul> <li>Compile statically (no dynamic linking)</li> <li>Be pure Rust, or optional FFI that can be disabled</li> <li>Avoid build scripts that invoke system tools</li> <li>Build with no extra linker args under musl or glibc</li> </ul>"},{"location":"22-Crate-Policy/#cryptography-hashing","title":"\ud83d\udd10 Cryptography &amp; Hashing","text":"<p>Only pure Rust implementations allowed.</p>"},{"location":"22-Crate-Policy/#approved","title":"\u2705 Approved:","text":"<ul> <li><code>sha2</code> (for SHA-256/SHA-512)</li> <li><code>blake3</code></li> <li><code>digest</code></li> <li><code>md-5</code></li> <li><code>hex</code></li> </ul>"},{"location":"22-Crate-Policy/#forbidden","title":"\u274c Forbidden:","text":"<ul> <li><code>ring</code> (requires C + custom asm)</li> <li><code>openssl</code> / <code>native-tls</code> (requires dynamic libs)</li> <li><code>libgit2</code>, <code>libz</code>, or anything with a <code>-sys</code> suffix</li> </ul>"},{"location":"22-Crate-Policy/#compression-archiving","title":"\ud83d\udce6 Compression &amp; Archiving","text":""},{"location":"22-Crate-Policy/#safe","title":"\u2705 Safe:","text":"<ul> <li><code>flate2</code> with <code>features = [\"miniz_oxide\"]</code> and <code>default-features = false</code></li> <li><code>tar</code></li> </ul>"},{"location":"22-Crate-Policy/#unsafe","title":"\u274c Unsafe:","text":"<ul> <li><code>flate2</code> with <code>zlib</code> feature</li> <li>Any crate that uses system-level compressors</li> </ul>"},{"location":"22-Crate-Policy/#feature-flag-rules","title":"\ud83d\udee0\ufe0f Feature Flag Rules","text":"<ul> <li>Optional features are great. Required features with native code are not.</li> <li>Default features must be fully statically linkable</li> <li>All crates should have the ability to compile cleanly for:</li> <li><code>x86_64-unknown-linux-musl</code></li> <li><code>aarch64-unknown-linux-musl</code></li> <li><code>x86_64-unknown-linux-gnu</code></li> </ul>"},{"location":"22-Crate-Policy/#crate-audit-tips","title":"\ud83d\udd2c Crate Audit Tips","text":"<p>Before adding a new crate:</p> <pre><code>cargo tree -e normal\n</code></pre> <p>Check for:</p> <ul> <li><code>-sys</code> crates</li> <li>Dynamic linking</li> <li>Build scripts (<code>build.rs</code>) doing sketchy stuff</li> <li>Optional features that need to be disabled</li> </ul>"},{"location":"22-Crate-Policy/#our-build-environment","title":"\ud83e\uddfc Our Build Environment","text":"<ul> <li><code>cargo build --release</code> must be enough</li> <li>No external toolchains, no linker magic</li> <li>CI or local builds should always work under:   <code>bash   RUSTFLAGS=\"-C target-feature=+crt-static\"</code></li> </ul>"},{"location":"22-Crate-Policy/#summary","title":"\u2705 Summary","text":"Requirement Policy TLS Support \u274c Optional only via <code>transport-https</code> Dynamic Linking \u274c Forbidden Shell Usage \u274c Forbidden C Libraries \u274c Forbidden unless optional and unused Cargo Build-Only \u2705 Required musl Compatibility \u2705 Required glibc Compatibility \u2705 Nice to have <p>Cosmos should build anywhere Rust does, with nothing but <code>cargo build</code> and a dream.</p>"},{"location":"23-Bootstrapping/","title":"23 \u2013 Bootstrapping a System with Cosmos","text":"<p>This guide walks through how to build a working root filesystem using Cosmos alone. It assumes you have a Cosmos binary, a Galaxy source (HTTP, file, or USB), and a directory to install into.</p> <p>This process works from live ISOs, recovery images, or even inside minimalist containers. If you can run the Cosmos binary, you can build a system.</p> <p>TL;DR Use this guide to go from zero to rootfs using Cosmos and a local Galaxy\u2014no shell, no dynamic linking, no nonsense.</p>"},{"location":"23-Bootstrapping/#what-is-bootstrapping","title":"\ud83c\udf1c What Is Bootstrapping?","text":"<p>Bootstrapping is the act of building a usable system from near-zero. With Cosmos, this means:</p> <ul> <li>No shell</li> <li>No package manager</li> <li>No userland</li> <li>Just a tarball or static binary and a goal</li> </ul> <p>Cosmos enables you to go from \"nothing but libc\" to a minimal, functional user environment.</p>"},{"location":"23-Bootstrapping/#requirements","title":"\u2705 Requirements","text":"<ul> <li>Statically compiled <code>cosmos</code> binary (no interpreter or dynamic libs)</li> <li>Galaxy source (USB, HTTP, Git clone, etc.)</li> <li>Writable mount point (e.g. <code>/mnt/wombat</code>)</li> </ul>"},{"location":"23-Bootstrapping/#install-process","title":"\ud83d\udd28 Install Process","text":"<pre><code># Optional: create target root\nmkdir -p /mnt/wombat\n\n# somewhere earlier, you add a local/mounted Galaxy\n\n# Install base system\ncosmos install --root /mnt/wombat core-stack\n\n# Bind system dirs for chroot\nmount --bind /dev /mnt/wombat/dev\nmount --bind /proc /mnt/wombat/proc\nmount --bind /sys /mnt/wombat/sys\n\n# Optional: copy /etc/passwd or minimal shadow configs\ncp -r /etc/skel /mnt/wombat/etc/\n\n# Chroot in\nchroot /mnt/wombat /bin/sh\n\n# Optional: validate install\nwhich sh\nls /\n</code></pre>"},{"location":"23-Bootstrapping/#what-to-install-first","title":"\ud83d\udd04 What to Install First","text":"<pre><code>cosmos install core-stack\ncosmos install net-tools\ncosmos install busybox\n</code></pre> <p><code>core-stack</code> is a placeholder for your base system. It can be a Nebula (metapackage). The goal is to get a minimal system up and running.</p> <p>A full Constellation file (e.g. <code>bootstrap.toml</code>) can define this list.</p> <pre><code>name = \"bootstrap\"\ndescription = \"Minimal system bootstrap\"\n\nmembers = [\n  \"core-stack\",\n  \"net-tools\",\n  \"busybox\",\n]\n</code></pre>"},{"location":"23-Bootstrapping/#use-cases","title":"\ud83c\udf10 Use Cases","text":"<ul> <li>Minimal Linux from scratch builds</li> <li>Custom distro bootstrapping</li> <li>Initramfs builds</li> <li>Embedded rescue environments</li> </ul>"},{"location":"23-Bootstrapping/#what-cosmos-does-not-do","title":"\ud83d\udeab What Cosmos Does Not Do","text":"<ul> <li>Partition drives</li> <li>Configure bootloaders</li> <li>Handle systemd or runit setup</li> </ul> <p>Cosmos installs files and packages\u2014nothing more. It is your tool for building a system, not for booting one.</p>"},{"location":"23-Bootstrapping/#pro-tips","title":"\ud83e\udef0 Pro Tips","text":"<ul> <li>Test bootstrap flows inside a container or VM before bare metal</li> <li>Keep a Galaxy synced to USB in case your network goes down</li> <li>Use a Nebula to define your base stack for repeatable installs</li> <li>Use <code>cosmos freeze</code> (future) to snapshot what you just installed</li> </ul> <p>With Cosmos, you can go from a blank directory to a bootable rootfs with only a few commands\u2014no interpreters, no curl, no Python, no tears.</p>"}]}